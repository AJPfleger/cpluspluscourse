\subsection{More STL}

\begin{frame}[fragile]
  \frametitlecpp[17]{Some new STL types}
  \begin{block}{\texttt{std::optional}}
    \begin{itemize}
    \item manages an optional contained value
    \item contextually converted to bool
    \item useful for the return value of a function that may fail
    \end{itemize}
  \end{block}
  \begin{block}{\texttt{std::any}}
    \begin{itemize}
    \item a type-safe container for single values of any type
    \item the \texttt{any\_cast} function provides type-safe access
    \item and throws \texttt{std::bad\_any\_cast} for bad access
    \end{itemize}
  \end{block}
  \begin{block}{\texttt{std::variant}}
    \begin{itemize}
    \item a type-safe union
    \item \texttt{std::get} reads the value of the variant
    \item and throws \texttt{std::bad\_variant\_access} for bad accesses
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{Some new STL types}
  \begin{block}{\texttt{std::string\_view}}
    \begin{itemize}
    \item Non owning view of a continuous char sequence
    \item Doesn't allocate memory, similar interface to std::string
    \item Easy to copy, Faster for many operations eg. substr (O(1) vs O(n))
    \item Please ensure that the string pointed to outlives the string\_view!
    \end{itemize}
    \begin{exampleblock}{Some example uses}
      \begin{cppcode*}{}
        std::string_view sv {"Some example"};
        auto first_word = sv.substr(0,sv.find_first_of(" "));

        constexpr std::string_view location {"Geneva,CH"};

        std::string some_string {"foo bar"};
        std::string_view sv_str(some_string);

        char foo[3] = {'f','o','o'};
        std::string_view carr(foo, std::size(foo));
      \end{cppcode*}
    \end{exampleblock}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{std::optional}
  \begin{itemize}
  \item Indicates the absence of a value with \texttt{std::nullopt}
  \item Has value semantics (Copy, Move, Compare, stack alloc.)
  \item Useful in place of pointers where value semantics are intuitive
  \end{itemize}
  \begin{exampleblock}{Code example}
    \begin{cppcode*}{}
      std::optional<Phone> parse_phone(std::string_view in) {
        if (is_valid_phone(in)) {
          return in; // automatic conv. to std::optional<Phone>(in);
        }
        return {}; // default constructs std::nullopt
      }
      ...
      auto v = parse_phone(get_input());
      if (v) {  // alternatively v.is_valid()
        process_phone(v.value()); // *v is equivalent
      }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{std::variant}
  \begin{itemize}
  \item Expresses intent that variable holds one of the types
  \item Makes it easy to implement visitor pattern
  \end{itemize}

  \begin{exampleblock}{Code example}
    \begin{cppcode*}{}
      using option_t = std::variant<int,float,string>;
      option_t opt; // default constructs first type
      std::variant<std::monostate, NonDefault, int, float> myvariant;
      opt = 100;
      int ival = std::get<int>(opt); // also std::get<0>(opt)
      try {
        float val = std::get<float>(opt) // will throw as opt is int
      } catch (const std::bad_variant_access& ex) {...}

      // Much easier with get_if returns a ptr or null if not conv.
      if (const float* val = std::get_if<float>(&opt))
          std::cout << "option type is f64, value=" << val;
    \end{cppcode*}
  \end{exampleblock}

\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{Visiting with std::variant}
    \begin{cppcode*}{}
      using option_t = std::variant<int,float,string>;
      struct Visitor {
        void operator() (int i) { std::cout<< "i32:"<< i;}
        void operator() (float f) { std::cout<< "f32:"<< f;}
        void operator() (std::string s) { std::cout<< "str:"<< s;}
      };
      void print_opt(option_t opt) {
        std::visit(Visitor{}, opt);
      }
      ...
      print_opt(100); print_opt(3.14f); print_opt("example");
    \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{std::any}
  \begin{itemize}
  \item Type safe alternative to void*
  \item Useful for passing arbitrary values across interfaces that may not know
    all the types
  \item \texttt{any\_cast} will only match concrete types, inheritance hierarchy
    is irrelevant
  \end{itemize}

  \begin{exampleblock}{Code example}
    \begin{cppcode*}{}
      class Orc: public Monster {...};

      void Player::attack(const std::any& e) {
        if (Monster *m = std::any_cast<Monster>(&e)) {
          m->take_hit(this->damage);
        } else if (Orc *o = std::any_cast<Orc>(&e)) {
          o->take_hit(this->damage*0.5); // Orc will only match this, not its parent
        } else if (Cat* c = std::any_cast<Cat>(&e)) { // No!
          c->pet();
        } ....
      }
    \end{cppcode*}
  \end{exampleblock}

\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{non-member begin and end}
  \begin{alertblock}{The problem in \cpp98}
    STL containers and arrays have different syntax for loop
    \vspace{-1mm}
    \begin{cppcode*}{}
      std::vector<int> v;
      int a[] = {1,2,3};
      for(auto it = v.begin(); it != v.end(); it++) {...}
      for(int i = 0; i < 3; i++) {...}
    \end{cppcode*}
  \end{alertblock}
  \pause
  \begin{block}{A new syntax}
    \begin{cppcode*}{firstnumber=5}
      for(auto it = begin(v); it != end(v); it++) {...}
      for(auto i = begin(a); i != end(a); i++) {...}
    \end{cppcode*}
  \end{block}
  \pause
  \begin{exampleblock}{Allowing the best syntax}
    \begin{cppcode*}{firstnumber=7}
      for(auto & element : v) {...}
      for(auto & element : a) {...}
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{Structured Binding Declarations}
  Helps when using tuples as a return type.\\
  Automatically creates variables and ties them.
  \begin{alertblock}{\cpp14}
    \begin{cppcode*}{}
      void foo(std::tuple<int, double, long> tuple) {
        int a = 0;
        double b = 0.0;
        long c = 0;
        // a, b, c need to be declared first
        std::tie(a, b, c) = tuple;
    \end{cppcode*}
  \end{alertblock}
  \begin{exampleblock}{\cpp17}
    \begin{cppcode*}{firstnumber=7}
      void foo(std::tuple<int, double, long> tuple) {
        auto [ a, b, c ] = tuple; ...
      }
      for (const auto& [key, value] : map) { ... }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{Compile-time branches with {\it if constexpr}}
  It requires a constant expression as condition,
  and is evaluated at compile time. Key benefit: the discarded
  branch can contain invalid code for the instantiated template arguments.
  \begin{cppcode*}{}
    template <typename Iterator, typename Dist>
    void advance( Iterator & i, Dist n) {
      using rtag = std::random_access_iterator_tag ;
      using itraits = std::iterator_traits<Iterator> ;
      using icat = typename itraits::iterator_category ;
      if constexpr (std::is_same_v<icat,rtag>) {
        i += n ;
      }
      else {
        if (n >= 0) while (n--) ++i ;
        else while (n++) --i ;
      }
    }
  \end{cppcode*}
\end{frame}
