\subsection[except]{Exceptions}

\begin{frame}[fragile]
  \frametitlecpp[98]{Exceptions}
  \begin{block}{The concept}
    \begin{itemize}
      \item to handle \textit{exceptional} events that cannot be foreseen
      \item to cleanly jump to a place where the error can be handled
    \end{itemize}
  \end{block}
  \begin{block}{In practice}
    \begin{itemize}
      \item add an exception handling block with {\it try ... catch} when exceptions are possible
      \item throw an exception using {\it throw} when a function cannot proceed (or recover internally)
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      #include <stdexcept>
      ...
      try {
        process_stream_data(s);
      } catch (const range_error& e) {
        cerr << e.what() << endl;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      process_stream_data(stream &s) {
        ...
        if (data_location >= buffer.length()) {
          raise range_error("buf overflow");
        }
        ...
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Exceptions}
  \begin{block}{Rules and Advice}
    \begin{itemize}
      \item any object can be thrown; best to use those in \texttt{stdexcept}
      \begin{itemize}
        \item define your own subclass of \texttt{std::exception} if needed
      \end{itemize}
      \item exceptions will be caught if the object type in the \textit{catch} clause matches
      \begin{itemize}
          \item if nothing catches an exception then \texttt{std::terminate} is called
          \item throw exceptions by value, catch them by (const) reference
      \end{itemize}
      \item all objects on the stack between the \textit{throw} and the \textit{catch} are destructed automatically
      \begin{itemize}
        \item this should give you a clean release of intermediate resources
        \item make sure you are using the RAII idiom in your own classes
      \end{itemize}
      \item use exceptions for \textit{unlikely} runtime errors outside the program's control (bad inputs, files unexpectedly not found, DB connection, \ldots)
      \item \textit{don't} use exceptions for logic errors in your code (consider \texttt{assert} and tests)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Exceptions}
  \begin{block}{A more illustrative example}
    \begin{itemize}
      \item exceptions are very powerful when there are many calls / lines of code between the error and where the error is handled
      \item they can also rather cleanly handle different types of errors
      \item \textit{try ... catch} statements can also be nested
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      try {
        for (const &file : files) {
          try {
            process_file(file);
          }
          catch (const file_bad &e) {
            ... // Skips one file
          }
        }
      } catch (const db_bad &e) {
        ... // This exception
            // aborts everything
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      int process_file(const fileobj file) {
        if (fh = open_file(file)) {
          throw
            file_bad(file.error.reason());
        }
        while (!fh) {
          line = read_line(fh);
          add_line_to_db(line); // Can throw
                                // db_bad
        }
        return 0;
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[98]{Error Handling and Exceptions}
  \begin{block}{}
    \begin{itemize}
      \item exceptions have little cost if no exception is thrown
      \begin{itemize}
        \item a throw itself typically costs about as much as a function call (the stack needs to be unwound, but needs to be done for C-style errors too)
        \item so minimal if you are using exceptions for \textit{exceptional} events
        \item thus their use is generally recommended
      \end{itemize}
      \item however, in a tight, performance-critical loop, where the error is handled close to the place it happens a C-style error code might be better
      \begin{itemize}
        \item But profile if you really want to find out!
      \end{itemize}
   \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\tiny,gobble=2}
      // try ... catch in hot loop
      //   might impact performance
      for (const &item: list) {
        try {
          check_item(item); // Can throw bad_item
          ... // process item
        }
        catch (bad_item &e) {
          ... // ignore this item, but keep going
        }
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\tiny,gobble=2}
      // For this code logic C-style error codes
      //   may be better
      for (const &item: list) {
        auto err_code = check_item(item);
        if (!err_code) {
          ... // process item
        } else {
          ... // warn and carry on
        }
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[11]{noexcept}
  \begin{block}{noexcept}
    \begin{itemize}
      \item specifying the \textit{noexcept} specifier states that a function is guaranteed throw an exception
      \begin{cppcode*}{fontsize=\scriptsize,gobble=2,linenos=false}
        int f() noexcept;
      \end{cppcode*}
      \begin{itemize}
        \item either no exceptions will be thrown or they are handled internally
        \item checked at compile time, so it allows the compiler to optimise around that knowledge
      \end{itemize}
      \item \textit{noexcept(expression)} specifier evaluates the expression and, if \textit{true}, the function won't throw
        \begin{cppcode*}{fontsize=\scriptsize,gobble=2,linenos=false}
          int safe_if_long_is_8_bytes() noexcept(sizeof(long)==8);
        \end{cppcode*}
      \item Use \textit{noexcept} on leaf functions where you can be sure of the behaviour
      \item Note that since C++11 destructors are \textit{noexcept} - never try and throw from them
    \end{itemize}
  \end{block}
\end{frame}
