\subsection[except]{Exceptions}

\begin{frame}[fragile]
  \frametitlecpp[98]{Exceptions}
  \begin{block}{The concept}
    \begin{itemize}
      \item to handle \textit{exceptional} events that cannot be foreseen
      \item to cleanly jump to the place where the error can be handled
    \end{itemize}
  \end{block}
  \begin{block}{In practice}
    \begin{itemize}
      \item add an exception handling block with {\it try ... catch}
      \item throw an exception within it using {\it throw}
    \end{itemize}
  \end{block}
  \begin{cppcode*}{fontsize=\scriptsize}
    #include <stdexcept>
    ...
    try {
      if (0 == divisor) {
        throw illegal_argument("Cannot divide by zero");
      }
      ... // Normal processing
    } catch (const invalid_argument& e) {
      cerr << e.what() << endl;
    }
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Exceptions}
  \begin{block}{Rules and Advice}
    \begin{itemize}
      \item any object can be thrown, but best to use those in \texttt{stdexcept}
      \begin{itemize}
        \item define your own subclass of \texttt{std::exception} if needed
      \end{itemize}
      \item exceptions will be caught if the object type of \textit{catch} matches
      \begin{itemize}
          \item if nothing catches an exception then \texttt{std::terminate} is called
          \item throw exceptions by value, catch them by (const) reference
      \end{itemize}
      \item all objects on the stack between the \textit{throw} and the \textit{catch} have their destructors called
      \begin{itemize}
        \item this should give you a clean release of intermediate resources
        \item make sure you are using the RAII idiom in your own classes
      \end{itemize}
      \item use exceptions for runtime errors like bad inputs, file not found, DB connection, \ldots
      \item \textit{don't} use exceptions for logic errors in your code (use \texttt{assert})
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Exceptions}
  \begin{block}{An more illustrative example}
    \begin{itemize}
      \item exceptions are very powerful when there are many calls / lines of code between the error and where the error is handled
      \item they can also rather cleanly handle different types of errors
      \item \textit{try ... catch} statements can also be nested
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      try {
        for (const &file : files) {
          try {
            process_file(file);
          }
          catch (const file_bad &e) {
            ... // Skips one file
          }
        }
      } catch (const db_bad &e) {
        ... // This exception
            // aborts everything
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      int process_file(const fileobj file) {
        if (fh = open_file(file)) {
          throw
            file_bad(file.error.reason());
        }
        while (!fh) {
          line = read_line(fh);
          add_line_to_db(line); // Can throw
                                // db_bad
        }
        return 0;
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[98]{Error Handling and Exceptions}
  \begin{block}{}
    \begin{itemize}
      \item exceptions have little cost if no exception is thrown
      \begin{itemize}
        \item a throw usually costs about as much as a function call
        \item so minimal if you are using exceptions for \textit{exceptional} events
        \item thus their use is generally recommended
      \end{itemize}
      \item however, in a tight, performance critical loop, where the error is handled close to the place it happens a C-style error code might be better
      \begin{itemize}
        \item But profile if you really want to find out!
      \end{itemize}
   \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\tiny,gobble=2}
      // try ... catch in hot loop
      //   might impact performance
      for (const &item: list) {
        try {
          check_item(item); // Can throw bad_item
          ... // process item
        }
        catch (bad_item &e) {
          ... // ignore this item, but keep going
        }
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\tiny,gobble=2}
      // For this code logic C-style error codes
      //   may be better
      for (const &item: list) {
        auto err_code = check_item(item);
        if (!err_code) {
          ... // process item
        } else {
          ... // warn and carry on
        }
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[11]{noexcept}
  \begin{block}{noexcept}
    \begin{itemize}
      \item specifying the \textit{noexcept} operator states that a function is guaranteed not to throw an exception
      \begin{cppcode*}{fontsize=\scriptsize,gobble=2,linenos=false}
        int f() noexcept;
      \end{cppcode*}
      \begin{itemize}
        \item either no exceptions will ever be thrown or any they are handled internally
        \item checked at compile time, so it allows the compiler to optimise around that knowledge
      \end{itemize}
      \item \textit{noexcept(expression)} evaluates the expression and, if \textit{true} the function won't throw
        \begin{cppcode*}{fontsize=\scriptsize,gobble=2,linenos=false}
          int safe_if_long_is_8_bytes() noexcept(sizeof(long)==8);
        \end{cppcode*}
      \item These uses can be nested, e.g.,
        \begin{cppcode*}{fontsize=\scriptsize,gobble=2,linenos=false}
          int ok_if_f_and_g_ok() noexcept(noexcept(f()) && noexcept(g()));
        \end{cppcode*}
      \item If you do use \textit{noexcept}, pay attention to destructors and don't allow exceptions to escape (or ever let resources leak)
    \end{itemize}
  \end{block}
\end{frame}
