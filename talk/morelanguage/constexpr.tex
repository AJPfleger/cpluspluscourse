\subsection[cstexpr]{Constant Expressions}

\begin{frame}[fragile]
  \frametitlecpp[14]{Generalized Constant Expressions}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item use functions to compute constant expressions at compile time
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example}
    \begin{cppcode*}{}
      constexpr int f(int x) {
        if (x > 1) return x * f(x - 1);
        return 1;
      }
      constexpr int a = f(5); // computed at compile time
      int b = f(n); // computed at runtime
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{\cpp11 allowed only a single return statement}
    \begin{cppcode*}{}
      constexpr int f(int x) {
        return x > 1 ? x * f(x - 1) : 1;
      }
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Static Assertions}
  \begin{block}{static\_assert declaration}
    \begin{itemize}
    \item Performs compile time assertions; meaning a failed assertion stops compilation
    \item The expression has to be a constant boolean expression
    \item Purely evaluated at compile time, no effect at runtime
    \item Often used in template programming to make assertions on types
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example}
    \begin{cppcode*}{}
      constexpr int f(int x) {
        return x > 1 ? x * f(x - 1) : 1;
      }
      static_assert(f(5)==120,"Expected f(5) to be 120!");
      static_assert(f(5)==120); // C++17
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[14]{Generalized Constant Expressions(2)}
  \begin{block}{Notes}
    \begin{itemize}
    \item A \mintinline{cpp}{constexpr} function \emph{may} be executed at compile time.
    \begin{itemize}
      \item Arguments must be \mintinline{cpp}{constexpr} or literals in order to benefit from compile time computation
      \item Function body must be visible to the compiler
    \end{itemize}
    \item A \mintinline{cpp}{constexpr} function can also be used at runtime
    \item A \mintinline{cpp}{constexpr} variable must be initialized at compile time
    \item Classes can have \mintinline{cpp}{constexpr} member functions
    \item Objects used in constant expressions must be of \emph{literal type}:
      \begin{itemize}
      \item an integral, floating-point, enum, reference, pointer type
      \item a union (of at least one) or array of literal types
      \item a class type with a \mintinline{cpp}{constexpr} constructor and
            the destructor is trivial (or \mintinline{cpp}{constexpr} since C++20)
      \end{itemize}
    \item A constexpr function is implicitly \mintinline{cpp}{inline} (header files)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile,shrink=15]
  \frametitlecpp[11]{Limitations of constexpr functions}
   \begin{alertblock}{C++11}
     \begin{itemize}
     \item Non-virtual function with a single return statement
     \end{itemize}
   \end{alertblock}
   \begin{alertblock}{C++14/C++17}
    \begin{itemize}
    \item no try-catch, goto or asm statements
    \item no uninitialized/static/thread\_local/non-literal-type variables
    \end{itemize}
  \end{alertblock}
   \begin{alertblock}{C++20}
    \begin{itemize}
    \item no coroutines or static/thread\_local/non-literal-type variables
    \item throw and asm statements allowed, but may not be executed
    \item transient memory allocation
          (memory allocated at compile-time must be freed again at compile-time)
    \item virtual functions and uninitialized variables allowed
    \end{itemize}
  \end{alertblock}
  \begin{alertblock}{C++23}
    \begin{itemize}
    \item no coroutines, or execution of throw and asm statements
    \item transient memory allocation
    \item everything else allowed
    \end{itemize}
  \end{alertblock}
  Further details on \href{https://en.cppreference.com/w/cpp/language/constexpr}{cppreference}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Real life example}
  \begin{cppcode*}{}
    constexpr float toSI(float v, char unit) {
      switch (unit) {
      case 'k': return 1000.0f*v;
      case 'm': return 0.001f*v;
      case 'y': return 0.9144f*v;
      case 'i': return 0.0254f*v;
      ...
      default: return v;
      }
    }
    constexpr float fromSI(float v, char unit) {
      switch (unit) {
        case 'k': return 0.001f*v;
        case 'y': return 1.093f*v;
      ...
      }
    }
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Real life example(2)}
  \begin{cppcode*}{}
    class DimLength {
      float m_value;
    public:
      constexpr DimLength(float v, char unit):
        m_value(toSI(v, unit)) {
      }
      constexpr float get(char unit) const {
        return fromSI(m_value, unit);
      }
    };
    constexpr DimLength km(1, 'k');
    constexpr float km_y = km.get('y');
    constexpr float km_i = km.get('i');
    static_assert(km_y == 1093, "expected km == 1093 yards!");
  \end{cppcode*}
\end{frame}
