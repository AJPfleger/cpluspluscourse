\section[C$^{++}$11]{C$^{++}$11 and C$^{++}$14 preview}

\subsection[Intro]{Introduction}

\begin{frame}
  \frametitle{Introduction to \cpp11 and \cpp14}
  \begin{block}{status}
    \begin{itemize}
    \item Latest \cpp specifications
    \item Not yet digested by most programmers
    \item Bringing a lot of goodies
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{How to use \cpp11 features}
    \begin{itemize}
    \item Use a compatible compiler gcc $\geq$ 4.8, clang $\geq$ 3.3
    \item add -std=c++11 to compilation flags
    \end{itemize}    
  \end{block}
  \begin{block}{How to use \cpp14 features}
    \begin{itemize}
    \item Use a compatible compiler gcc $\geq$ 4.9, clang $\geq$ 3.4
    \item add -std=c++14 to compilation flags
    \end{itemize}    
  \end{block}
\end{frame}

\subsection[loop]{Range based loops}

\begin{frame}[fragile]
  \frametitle{Range based loops}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item simplifies loops tremendously
    \item especially with STL containers
    \end{itemize}
  \end{block}
  \begin{block}{Syntax}
    \begin{cppcode*}{linenos=false}
      for ( type iteration_variable : container ) {
        // body using iteration_variable
      }
    \end{cppcode*}
  \end{block}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      int sum = 0;
      for (int a : v) { sum += a; }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[auto]{auto keyword}

\begin{frame}[fragile]
  \frametitle{Auto keyword}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item many type declarations are redundant
    \item and lead to compiler error if you mess up
    \end{itemize}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      int a = v[3];
      int b = v.size();  // bug ? unsigned to signed
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{New way}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      auto a = v[3];
      auto b = v.size();
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Loops and auto keyword with the STL}
  \begin{block}{Old way}
    \begin{cppcode*}{}
      std::vector<int> v;
      int sum = 0;
      for (std::vector<int>::iterator it = a.begin();
           it != a.end();
           it++) {
        sum += *it;
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{New way}
    \begin{cppcode*}{}
      std::vector<int> v;
      int sum = 0;
      for (auto a : v) { sum += a; }
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[begin]{non-member begin/end}

\begin{frame}[fragile]
  \frametitle{non-member begin and end}
  \begin{alertblock}{The problem}
    STL containers and arrays have different syntax for loop
    \begin{cppcode}
      std::vector<int> v;
      for(it = v.begin(); it != v.end(); it++) {...}
      int a[] = {1,2,3};
      for(i = 0; i < 3; i++) {...}
    \end{cppcode}
  \end{alertblock}
  \pause
  \begin{block}{The new syntax}
    \begin{cppcode}
      std::vector<int> v;
      for(auto it = begin(v); it != end(v); it++) {...}
      int a[] = {1,2,3};
      for(int* i = begin(a); i != end(a); i++) {...}
    \end{cppcode}
  \end{block}
\end{frame}

\subsection[init]{Initializers}

\begin{frame}[fragile]
  \frametitle{Initializers - objects}
  \begin{block}{\cpp98 nightmare}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=4}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=4,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \pause
    \begin{cppcode*}{gobble=2, firstnumber=12}
      A a(1,2);       // A::A(int, int)
      A a(1);         // A::A(int)
      A a();          // declaration of a function !
      A a;            // A::A()
      B b = {1, 2.3}; // OK
      A a = {1,2};    // not allowed
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initializers - objects}
  \begin{block}{\cpp11 uniformization}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=4}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=4,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \begin{cppcode*}{gobble=2, firstnumber=12}
      A a{1,2};       // A::A(int, int)
      A a{1};         // A::A(int)
      A a{};          // A::A()
      A a;            // A::A()
      B b = {1, 2.3}; // OK
      A a = {1,2};    // OK, A::A(int, int)
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initializers - arrays and vectors}
  \begin{block}{\cpp98 nightmare}
    \begin{cppcode*}{firstnumber=10}
     int ip[3] = {1,2,3};          // OK
     int* ip = new int[3]{1,2,3};  // not allowed
     std::vector<int> v = {1,2,3}; // not allowed
    \end{cppcode*}
  \end{block}
  \pause
  \begin{exampleblock}{\cpp11 uniformization}
    \begin{cppcode*}{firstnumber=10}
     int ip[3] = {1,2,3};          // OK
     int* ip = new int[3]{1,2,3};  // OK
     std::vector<int> v = {1,2,3}; // OK
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[exc]{Exceptions}

\begin{frame}[fragile]
  \frametitle{Deprecation of \cpp98 exceptions}
  \begin{block}{}
    After a lot of thinking and experiencing, the conclusions of the community on exception handling are :
    \begin{itemize}
    \item Never write an exception specification
    \item Except possibly an empty one
    \end{itemize}
  \end{block}
  \pause
  \begin{alertblock}{Some of the reasons}
    \begin{itemize}
    \item throw specification is runtime only
      \begin{itemize}
      \item does not allow compiler optimizations
      \item on the contrary forces extra checks
      \item generally terminates your program if violated
      \end{itemize}
    \item throw specification clashes with templates
      \begin{itemize}
      \item one cannot ``template'' the throw clause
      \end{itemize}
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What remains \cpp11/14}
  \begin{block}{throw is dead}
    \begin{itemize}
    \item throw statements are deprecated
    \item even throw() (no exceptions)
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{long live noexcept}
    \begin{itemize}
    \item noexcept a somehow equivalent to throw()
    \item but is checked at compile time
    \item so allows compiler optimizations
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Full power of noexcept}
  \begin{block}{3 uses of noexcept}
    \begin{itemize}
    \item standalone
      \begin{cppcode*}{gobble=2, linenos=false}
        int f() noexcept;
      \end{cppcode*}
    \item as an expression saying whether exceptions can be sent
      \begin{cppcode*}{gobble=2, linenos=false}
        int f() noexcept(sizeof(long) == 8);
      \end{cppcode*}
    \item as an operator to know whether a function launches exceptions
      \begin{cppcode*}{gobble=2, linenos=false}
        template <class T> void foo()
             noexcept(noexcept(T())) {};
      \end{cppcode*}
   \end{itemize}
  \end{block}
\end{frame}

\subsection[$\lambda$]{Lambdas}

\begin{frame}[fragile]
  \frametitle{Function return type}
  \begin{block}{A new way to specify function's return type}
    \begin{cppcode*}{linenos=false}
      ReturnType fn_name(ArgType1, ArgType2);  //old
      auto fn_name(ArgType1, ArgType2) -> ReturnType;
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{Advantages}
    \begin{itemize}
    \item Allows to simplify inner type definition
      \begin{cppcode*}{linenos=false,gobble=4}
        class TheClass {
          typedef int inner_type;
          inner_type func();
        }
        TheClass::inner_type TheClass::func() {...}
        auto TheClass::func() -> inner_type {...}
      \end{cppcode*}
    \item will be used for lambdas
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Lambdas}
  \begin{block}{Definition}
    a lambda is a function with no name
  \end{block}
  \pause
  \begin{exampleblock}{Python example}
    \begin{pythoncode*}{}
      data = [1,9,3,8,3,7,4,6,5]

      # without lambdas
      def isOdd(n):
        return n%2 == 1
      print filter(isOdd, data)

      # with lambdas
      print filter(lambda n:n%2==1, data)
    \end{pythoncode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp Lambdas}
  \begin{block}{Simplified syntax}
    \begin{cppcode*}{gobble=2}
      [] (args) -> type {
        code;
      }
    \end{cppcode*}
    The type specification is optionnal
  \end{block}
  \begin{exampleblock}{Usage example}
    \begin{cppcode*}{gobble=2}
      std::vector<int> data{1,2,3,4,5};
      for_each(begin(data), end(data),
               [](int i) {
                 std::cout << "The square of " << i
                           << " is " << i*i << std::endl;
               });
    \end{cppcode*}
  \end{exampleblock}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Capture}
  \begin{block}{Python code}
    \begin{pythoncode*}{}
      increment = 3
      data = [1,9,3,8,3,7,4,6,5]
      map(lambda x : x + increment, data)
    \end{pythoncode*}
  \end{block}
  \pause
  \begin{block}{First attempt in \cpp}
    \begin{cppcode}
      int increment = 4;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
               [](int x) { std::cout << x+increment; });
      std::cout << std::endl;
    \end{cppcode}
  \end{block}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=6]{text}
        error: 'increment' is not captured
          [](int x) { std::cout << x+increment; });
                                     ^
    \end{minted}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture}
  \begin{block}{Variable capture}
    \begin{itemize}
    \item external variables need to be explicitely captured
    \item captured variables are listed within initial []
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example}
    \begin{cppcode*}{}
      int increment = 4;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
               [increment](int x) {
                 std::cout << x+increment;
               });
      std::cout << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Default capture is by value}
  \begin{exampleblock}{Code example}
    \begin{cppcode}
      int sum = 0;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [sum](int x) { sum += x; });
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=4]{text}
      error: assignment of read-only variable 'sum'
               [sum](int x) { sum += x; });
    \end{minted}
  \end{alertblock}
  \pause
  \begin{block}{Explanation}
    By default, variables are captured by value
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture by reference}
  \begin{exampleblock}{Simple example}
    In order to capture by reference, add '\&' before the variable
    \begin{cppcode}
      int sum = 0;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [&sum](int x) { sum += x; });
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Mixed case}
    One can of course mix values and references
    \begin{cppcode}
      int sum = 0, offset = 1;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [&sum, offset](int x) {
                sum += x + offset;
              });
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture all}
  \begin{block}{by value}
    \begin{cppcode*}{linenos=false}
      [=](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{by reference}
    \begin{cppcode*}{linenos=false}
      [&](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{exceptions}
    \begin{cppcode*}{linenos=false}
      [&, b](...) { ... };
      [=, &b](...) { ... };
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Closures}
  \begin{exampleblock}{Example}
    \begin{cppcode*}{}
      auto build_incrementer = [](int inc) {
        return [inc](int value) { return value + inc; };
      };
      auto inc1 = build_incrementer(1);
      auto inc10 = build_incrementer(10);
      int i = 0;
      inc1(i);   // i = 1
      inc10(i);  // i = 11
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{How it works}
    \begin{itemize}
      \item build\_incrementer returns a function object
      \item this function's behavior depends on a parameter
      \item note how {\it auto} is useful here !
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp11 makes the STL usable}
  \begin{block}{Before lambdas}
    \begin{cppcode*}{}
      struct Incrementer {
        int m_inc;
        Incrementer(int inc) : m_inc(inc) {}
        int operator() (int value) {
          return value + m_inc;
        };
      };
      std::vector<int> v;
      v.push_back(1); v.push_back(2); v.push_back(3);
      std::transform(v.begin(), v.end(), v.begin(),
                     Incrementer(1));
      for (std::vector<int>::iterator it = v.begin();
           it != v.end();
           it++) std::cout << *it << " ";
      \end{cppcode*}
    \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp11 makes the STL usable}
  \begin{exampleblock}{With lambdas}
    \begin{cppcode*}{}
      std::vector<int> v = {1, 2, 3};
      int inc = 1;
      std::transform(v.begin(), v.end(), v.begin(),
                     [inc](int value) {
                       return value + inc;
                     });
      for (auto a : v) std::cout << a << " ";
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Conclusion}
    Use the STL !
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lambdas}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/lambdas
    \item look at the code (it's the solution to the stl exercise)
    \item use lambdas to simplify it
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection[mv]{Move semantic}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Non efficient code}
    \begin{cppcode*}{}
      template <class T>
      void swap(T &a, T &b) {
        T c = a;
        a = b;
        b = c;
      }
      std::vector<int> v, w;
      for (int i = 0; i < 10000; i++) v.push_back(i);
      for (int i = 0; i < 10000; i++) w.push_back(i);
      swap(v, w);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What really happens during swap}
    \begin{itemize}
    \item 30k allocations + 30k releases
    \item 30k copies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Dedicated efficient code}
    \begin{cppcode*}{}
      std::vector<int> v, w;
      for (int i = 0; i < 10000; i++) v.push_back(i);
      for (int i = 0; i < 10000; i++) w.push_back(i);
      v.swap(w);
      \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{What probably happens during swap}
    \begin{itemize}
    \item 3 allocations + 3 releases
    \item 3 copies
    \end{itemize}
    only the pointers to underlying arrays were swapped
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Another non efficient code}
    \begin{cppcode*}{}
      std::vector<int> vrandom(unsigned int n) {
        std::vector<int> result;
        for (int i = 0; i < n; i++) {
          result.push_back(rand());
        }
        return result;
      }
      std::vector<int> v = vrandom(10000);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What really happens during assignment}
    \begin{itemize}
    \item 10k allocations + 10k releases
    \item 10k copies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Dedicated efficient way}
    \begin{cppcode*}{}
      void vrandom(unsigned int n, std::vector<int> &v) {
        for (int i = 0; i < n; i++) {
          v.push_back(rand());
        }
      }
      std::vector<int> v;
      vrandom(10000, v);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{The ideal situation}
    Have a way to express that we move the vector's content
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{The idea}
    \begin{itemize}
      \item a new type of reference : rvalue references
      \begin{itemize}
      \item used for move semantic
      \item denoted by \&\&
      \end{itemize}
      \item 2 new members in every class, with move semantic :
      \begin{description}
      \item[a move constructor] similar to copy constructor
      \item[a move assignment operator] similar to assignment operator (now called copy assignment operator)
      \end{description}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{}
      T(const T&  other); // copy construction
      T(      T&& other); // move construction
      T& operator=(const T&  other); // copy assignment
      T& operator=(      T&& other); // move assignment
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{A few important points concerning move semantic}
    \begin{itemize}
    \item the whole STL can understand the move semantic
    \item move assignment operator is allowed to destroy source
      \begin{itemize}
      \item so do not reuse source afterward
      \item still, I advice to never leave inconsistent objects
      \end{itemize}
    \item if not implemented, move falls back to copy version
    \item move is called by the compiler whenever possible
      \begin{itemize}
      \item e.g. when passing temporary
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{}
      T a;
      T b = a;      // 1. Copy assign
      T c = T(2);   // 2. Move assign
      T d = func(); // 3. Move assign
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{In some cases, you want to force a move}
    \begin{cppcode*}{}
      template <class T> void swap(T &a, T &b) {
        T c = a;  // copy
        a = b;    // copy
        b = c;    // copy
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{There are mainly two ways}
    \begin{itemize}
    \item casting to an rvalue reference
    \item using the std::move function
    \end{itemize}
    \begin{cppcode*}{}
      T a;
      T b = a;                   // 1. Copy assign
      T c = std::move(a);        // 4. Move assign
      T d = static_cast<T&&>(a); // 5. Move assign
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Diversion : constructor delegation}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid replication of code in several constructors
    \item by delegating to another constructor, in the initializer list
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Delegate {
        Delegate() { ... complex initialization ...};
        Delegate(int i) : Delegate(), m_i(i) {};
      }
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the easy way}
  \begin{block}{Use copy and swap idiom}
    \begin{itemize}
    \item implement an efficient swap method to your class
      \begin{itemize}
      \item preferably outside the class so that it is symetric
      \end{itemize}
    \item use swap for move constructor
      \begin{itemize}
      \item create empty object with constructor delegation
      \item swap it with source
      \end{itemize}
    \item use swap in move assignment
      \begin{itemize}
      \item pass parameter by value
      \item this should force creation of a local replica of source
      \item as we are in the move assignment \\
        our move constructor will be called \\
        and source will be filled with an empty object
      \item swap local object with *this
      \item let local object be destructed when exiting the method \\
        this will actually destroy the original content of the target
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the easy way}
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{}
      class Movable {
        Movable();
        Movable(Movable &&other) :
          Movable() {         // constructor delegation
          swap(*this, other);
        }
        Movable& operator=(Movable other) { // by value
          swap(*this, other);
          return *this;
        }
        friend void swap(Movable &a, Movable &b);
      };
      void swap(Movable &a, Movable &b);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move Semantic}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/move
    \item look at the code and run it with callgrind
    \item understand how inefficient it is
    \item implement move semantic the easy way in NVector
    \item run with callgrind and see no improvement
    \item understand why and fix test.cpp
    \item see efficiency improvements
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection[RAII]{pointers and RAII}

\begin{frame}[fragile]
  \frametitle{nullptr}
  \begin{block}{Finally a \cpp~NULL pointer}
    \begin{itemize}
    \item works like 0 or NULL in standard cases
    \item triggers compilation error when mapped to integer
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      void* vp = nullptr;
      int* ip = nullptr;
      int i = NULL;      // OK -> bug ?
      int i = nullptr;   // ERROR
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pointers : why they are error prone ?}
  \begin{exampleblock}{They need initialization
      \hfill \onslide<2->{\textcolor{orange}{\bf Seg Fault}}}
    \begin{cppcode*}{linenos=false}
      char *s;
      try {
        foo();
        s = (char*) malloc(...);
        strncpy(s, ...);
      } catch (...) { ... }
      bar(s);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \pause
  \vspace{-2cm}
  \begin{exampleblock}{They need to be released
      \hfill \onslide<4->{\textcolor{orange}{\bf Memory leak}}}
    \begin{cppcode*}{linenos=false}
      char *s = (char*) malloc(...);
      strncpy(s, ...);
      if (0 != strncmp(s, ...)) return;
      foo(s);
      free(s);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \pause
  \vspace{-2cm}
  \begin{exampleblock}{They need clear ownership
      \hfill \onslide<6->{\textcolor{orange}{\bf Who should release ?}}}
    \begin{cppcode*}{linenos=false}
      char *s = (char*) malloc(...);
      strncpy(s, ...);
      someVector.push_back(s);
      someSet.add(s);
      std::thread t1(vecConsumer, someVector);
      std::thread t2(setConsumer, someSet);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{This problem exists for any resource}
  \begin{exampleblock}{For example with a file}
    \begin{cppcode*}{}
      try {
        FILE *handle = std::fopen(path, "w+");
        if (0 == handle) { throw ... }
        if (std::fputs(str, handle) == EOF) {
          throw ...
        }
        fclose(handle);
      } catch (...) { ... }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Resource Acquisition Is Initialization}
  \begin{block}{Practically}
    Use object semantic to acquire/release resources
    \begin{itemize}
    \item wrap the resource inside an object
    \item acquire resource via object constructor
    \item release resource in destructor
    \item create this object on the stack so that it is automatically destructed when leaving the scope
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII in practice}
  \begin{exampleblock}{File class}
    \begin{cppcode*}{}
      class File {
      public:
        File(const char* filename) :
          m_file_handle(std::fopen(filename, "w+")) {
          if (m_file_handle == NULL) { throw ... }
        }
        ~File() { std::fclose(m_file_handle); }
        void write (const char* str) {
          if (std::fputs(str, m_file_handle) == EOF) {
            throw ...
          }
        }
      private:
        FILE* m_file_handle;
      };
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII usage}
  \begin{exampleblock}{Usage of File class}
    \begin{cppcode*}{}
      void log_function() {
        // file opening, aka resource acquisition
        File logfile("logfile.txt") ;

        // file usage
        logfile.write("hello logfile!") ;

        // file is automatically closed by the call to
        // its destructor, even in case of exception !
      }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{std::unique\_ptr}
  \begin{block}{an RAII pointer}
    \begin{itemize}
    \item wraps a regular pointer
    \item has move only semantic
      \begin{itemize}
      \item the pointer is only owned once
      \end{itemize}
    \item in \textless{}memory\textgreater{} header
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Usage}
    \begin{cppcode*}{}
      Foo *p = new Foo{};  // allocation
      std::unique_ptr<Foo> uptr(p);
      std::cout << uptr.get() << " points to "
                << uptr->someMember << std::endl;
      void f(std::unique_ptr<Foo> ptr);
      f(std::move(uptr)); // transfer of ownership
      // deallocation when exiting f
      std::cout << uptr.get() << std::endl; // 0
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quizz}
  \begin{exampleblock}{}
    \begin{cppcode*}{}
      Foo *p = new Foo{};  // allocation
      std::unique_ptr<Foo> uptr(p);
      void f(std::unique_ptr<Foo> ptr);
      f(uptr); // transfer of ownership
    \end{cppcode*}
    What do you expect ?
  \end{exampleblock}
  \pause
  \begin{alertblock}{Compilation Error}
    \begin{minted}{text}
test.cpp:15:5: error: call to deleted constructor
of 'std::unique_ptr<Foo>'
  f(uptr);
    ^~~~
/usr/include/c++/4.9/bits/unique_ptr.h:356:7: note:
 'unique_ptr' has been explicitly marked deleted here
 unique_ptr(const unique_ptr&) = delete;
 ^
    \end{minted}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{std::make\_unique}
  \begin{block}{}
    \begin{itemize}
    \item allocates directly a unique\_ptr
    \item no new or delete calls anymore !
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{make\_unique usage}
    \begin{cppcode*}{}
      // allocation of one Foo object,
      // calling constructor with one argument
      auto a = std::make_unique<Foo>(memberValue);
      std::cout << a.get() << " points to "
                << a->someMember << std::endl;
      // allocation of an array of Foos
      // calling default constructor
      auto b = std::make_unique<Foo[]>(10);
      // deallocations
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII or raw pointers}
  \begin{block}{When to use what ?}
    \begin{itemize}
    \item Always use RAII for allocations
    \item You thus never have to deallocate !
    \item Use raw pointers for observer functions (or references)
      \begin{itemize}
      \item remember that unique\_ptr is move only
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{A question of ownership}
    \begin{cppcode*}{}
      unique_ptr<T> producer();
      void observer(T*);
      void consumer(unique_ptr<T>);

      unique_ptr<T> pt{producer()};
      observer(pt.get());       // Keep ownership
      consumer(std::move(pt));  // Transfer ownership
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{unique\_ptr usage summary}
  \begin{block}{It's about lifetime management}
    \begin{itemize}
    \item Use unique\_ptr in functions taking part to the lifetime management
    \item Otherwise use raw pointers or references
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{shared\_ptr, make\_shared}
  \begin{block}{shared\_ptr : a reference counting pointers}
    \begin{itemize}
    \item wraps a regular pointer like unique\_ptr
    \item has move and copy semantic
    \item uses internally reference counting
      \begin{itemize}
      \item "Would the last person out, please turn off the lights ?"
      \end{itemize}
    \item is thread safe, thus the reference counting is costly
    \end{itemize}
  \end{block}
  \begin{block}{make\_shared : creates a shared\_ptr}
    \begin{cppcode*}{}
      {
        auto sp = std::make_shared<Foo>(); // #ref = 1
        vector.push_back(sp);              // #ref = 2
        set.insert(sp);                    // #ref = 3
      } // #ref 2
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[thr]{Concurrency and asynchronicity}

\begin{frame}[fragile]
  \frametitle{Basic concurrency}
  \begin{block}{Threading}
    \begin{itemize}
    \item new object std::thread in \textless{}thread\textgreater{} header
    \item takes a function as argument of its constructor
    \item must be called on join or program is terminated
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      void doSth() {...};
      void doSthElse() {...};
      int main() {
        std::thread t1(doSth);
        std::thread t2(doSthElse);
        for (auto t: {&t1,&t2}) t->join();
      }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The thread constructor}
  \begin{exampleblock}{Can take a function and its arguments}
    \begin{cppcode*}{}
      void function(int j, double j) {...};
      std::thread t1(function, 1, 2.0);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Can take any function like object}
    \begin{cppcode*}{}
      struct AdderFunctor {
        AdderFunctor(int i): m_i(i) {}
        int operator() (int j) { return i+j; };
        int m_i;
      };
      std::thread t2(AdderFunctor(2), 5);
      int a;
      std::thread t3([](int i) { return i+2; }, a);
      std::thread t4([a]       { return a+2; });
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Basic asynchronicity}
  \begin{block}{Concept}
    \begin{itemize}
    \item separation of the specification of what should be done and the retrieval of the results
    \item ``start working on this, and ping me when it's ready''
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{Pratically}
    \begin{itemize}
    \item std::async function launches and asynchronous task
    \item std::future template allows to handle the result
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      int computeSth() {...}
      std::future<int> res = std::async(computeSth);
      std::cout << res->get() << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mixing the two}
  \begin{block}{Is async running concurrent code ?}
    \begin{itemize}
    \item it depends !
    \item you can control this with a launch policy argument
      \begin{description}
      \item[std::launch::async] spawns a thread for immediate execution
      \item[std::launch::deferred] causes lazy execution in current thread
      \end{description}
      \begin{itemize}
      \item execution starts when get() is called
      \end{itemize}
    \item default is not specified !
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Usage}
    \begin{cppcode*}{}
      int computeSth() {...}
      auto res = std::async(std::launch::async,
                            computeSth);
      auto res2 = std::async(std::launch::deferred,
                             computeSth);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fine grained control on asynchronous execution}
  \begin{block}{std::packaged\_task template}
    \begin{itemize}
    \item creates an asynchronous version of any function like object
      \begin{itemize}
      \item identical arguments
      \item returns a std::future
      \end{itemize}
    \item provides access to the returned future
    \item associated with threads, gives full control on execution
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Usage}
    \begin{cppcode*}{}
      int task() { return 42; }
      std::packaged_task<int()> pckd_task(task);
      auto future = pckd_task.get_future();
      pckd_task();
      std::cout << future.get() << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[mutex]{Mutexes}

\begin{frame}[fragile]
  \frametitle{Races}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      int a = 0;
      void inc() { a++; };
      void inc100() {
        for (int i=0; i < 100; i++) inc();
      };
      int main() {
        std::thread t1(inc100);
        std::thread t2(inc100);
        for (auto t: {&t1,&t2}) t->join();
        std::cout << a << std::endl;
      }
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{What do you expect ? Try it in code/race}
    \pause
    Anything between 100 and 200 !!!
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Atomicity}
  \begin{exampleblock}{Definition (wikipedia)}
    \begin{itemize}
    \item an operation (or set of operations) is atomic if it appears to the rest of the system to occur instantaneously
    \end{itemize}
  \end{exampleblock}
  \begin{block}{Practically}
    \begin{itemize}
    \item an operation that won't run concurrently to another one
    \item an operation that will have a stable environment during execution
    \end{itemize}
  \end{block}
  \pause
  \begin{alertblock}{Is ++ operator atomic ?}
    \pause
    Usually not. It behaves like :
    \begin{cppcode*}{linenos=false}
      eax = a       // memory to register copy
      increase eax  // increase (atomic CPU instruction)
      a = eax       // copy back to memory
    \end{cppcode*}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Timing}
  \begin{exampleblock}{Code}
    \begin{cppcode*}{linenos=false}
      eax = a       // memory to register copy
      increase eax  // increase (atomic CPU instruction)
      a = eax       // copy back to memory
    \end{cppcode*}
  \end{exampleblock}
  \begin{block}{For 2 threads}
    \begin{tikzpicture}
      \begin{umlseqdiag}
        \umlobject[x=0, class=eax]{Thread 1}
        \umlobject[x=3, class=a, fill=blue!20]{Memory}
        \umlobject[x=6, class=eax]{Thread 2}
        \begin{umlcall}[op=read, type=synchron, return=0]{Thread 1}{Memory}
        \end{umlcall}
        \begin{umlcall}[padding=3, op=read, type=synchron, return=0]{Thread 2}{Memory}
        \end{umlcall}
        \begin{umlcallself}[op=incr, type=synchron]{Thread 1}
        \end{umlcallself}
        \begin{umlcallself}[op=incr, type=synchron]{Thread 2}
        \end{umlcallself}
        \begin{umlcall}[op=write 1]{Thread 2}{Memory}
        \end{umlcall}
        \begin{umlcall}[padding=3, op=write 1]{Thread 1}{Memory}
        \end{umlcall}
      \end{umlseqdiag}
      \draw[-triangle 60](8.5,0) -- (8.5,-4) node[right, pos=0.5]{time};
    \end{tikzpicture}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutexes}
  \begin{block}{Concept}
    \begin{itemize}
    \item a lock to serialize access to a non atomic piece of code
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{The objects}
    \begin{description}[labelwidth=1.8cm]
    \item[std::mutex] in the mutex header
    \item[std::lock\_guard] for an RAII version of it
    \item[std::unique\_lock] same and can be released/relocked
    \end{description}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{}
      int a = 0;
      std::mutex m;
      void inc() {
        std::lock_guard<std::mutex> guard(m);
        a++;
      };
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutexes}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item Go to code/race
    \item Look at the code and try it\\
      See that it has a race condition
    \item Use a mutex to fix the issue
    \item See the difference in execution time
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dead lock}
  \begin{exampleblock}{Scenario}
    \begin{itemize}
    \item 2 mutexes, 2 threads
    \item locking order different in the 2 threads
    \end{itemize}
  \end{exampleblock}
  \pause
  \begin{block}{Sequence diagram}
    \begin{tikzpicture}
      \begin{umlseqdiag}
        \umlobject[x=0]{Thread 1}
        \umlobject[x=2.5, fill=blue!20]{Mutex A}
        \umlobject[x=5, fill=blue!20]{Mutex B}
        \umlobject[x=7.5]{Thread 2}
        \begin{umlcall}[op=lock]{Thread 1}{Mutex A}
        \end{umlcall}
        \begin{umlcall}[op=lock, dt=6]{Thread 2}{Mutex B}
        \end{umlcall}
        \begin{umlcall}[op=lock (block), dt=6]{Thread 1}{Mutex B}
        \end{umlcall}
        \begin{umlcall}[op=lock (block), dt=12]{Thread 2}{Mutex A}
        \end{umlcall}
      \end{umlseqdiag}
      \draw[-triangle 60](9,0) -- (9,-4) node[right, pos=0.5]{time};
    \end{tikzpicture}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How to avoid dead locks}
  \begin{block}{Possible solutions}
    \begin{itemize}
    \item Never take several locks
      \begin{itemize}
      \item Or add master lock protecting the locking phase
      \end{itemize}
    \item Respect a strict order in the locking across all threads
    \item Do not use locks
      \begin{itemize}
      \item Use other techniques, e.g. queues
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Condition variables}
  \begin{block}{How to express thread dependencies}
    \begin{itemize}
    \item Allows a thread to sleep until a given condition is satisfied
    \item std::condition\_variable object from condition\_variable header
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{Usage}
    \begin{itemize}
    \item wraps an RAII lock around a mutex
    \item wait() will hang until the condition is met
      \begin{itemize}
      \item you can have several waiters sharing the same mutex
      \end{itemize}
    \item notify\_one() will wake up on waiter
    \item notify\_all() will wake up all waiters
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Condition variable usage}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      int value = -1;
      std::mutex mutex;
      std::condition cond;
      auto t = std::thread([] () {
        value = ... long process ...;
        cond.notify_all();
      });
      auto t = std::thread([] () {
        std::unique_lock<std::mutex> lock{mutex};
        cond.wait(lock, [] { return value > 0; });
        ... use value ...
      });
      { std::unique_lock<std::mutex> lock{mutex};
        cond.wait(lock, [] { return value > 0; });
        std::cout << value << std::endl; }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}
