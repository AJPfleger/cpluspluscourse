\section[C$^{++}$11]{C$^{++}$11 preview}

\subsection[Intro]{Introduction}

\begin{frame}
  \frametitle{Introduction to \cpp11}
  \begin{block}{status}
    \begin{itemize}
    \item Latest \cpp specification
    \item Not yet digested by most programmers
    \item Bringing a lot of goodies
    \end{itemize}        
  \end{block}
  \pause
  \begin{block}{How to use it}
    \begin{itemize}
    \item Use a compatible compiler gcc $\geq$ 4.8, clang $\geq$ 3.3
    \item add -std=c++11 to compilation flags
    \end{itemize}    
  \end{block}
\end{frame}

\subsection[nullptr]{nullptr}

\begin{frame}[fragile]
  \frametitle{nullptr}
  \begin{block}{Finally a \cpp NULL pointer}
    \begin{itemize}
    \item works like 0 or NULL in standard cases
    \item provokes compilation error when mapped to integer
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{linenos=false}
      void* vp = nullptr;
      int* ip = nullptr;
      int i = NULL;      // OK -> bug ?
      int i = nullptr;   // ERROR
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[Loops]{Range based loops}

\begin{frame}[fragile]
  \frametitle{Range based loops}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item simplifies loops tremendously
    \item especially with STL containers
    \end{itemize}
  \end{block}
  \begin{block}{Syntax}
    \begin{cppcode*}{linenos=false}
      for ( type iteration_variable : container ) {
        // body using iteration_variable
      }
    \end{cppcode*}
  \end{block}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      int sum = 0;
      for (int a : v) { s += a; }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[auto]{auto keyword}

\begin{frame}[fragile]
  \frametitle{Auto keyword}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item many type declarations are redundant
    \item and lead to compiler error if you mess up
    \end{itemize}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      int a = v[3];
      int b = v.size();  // bug ? unsigned to signed
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{New way}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      auto a = v[3];
      auto b = v.size();
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Loops and auto keyword with the STL}
  \begin{block}{Old way}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v;
      int sum = 0;
      for (std::vector<int>::iterator it = a.begin();
           it != a.end();
           it++) {
        sum += *it;
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{New way}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v;
      int sum = 0;
      for (auto a : v) { sum += a; }
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[begin]{non-member begin/end}

\begin{frame}[fragile]
  \frametitle{non-member begin and end}
  \begin{alertblock}{The problem}
    STL containers and arrays have different syntax for loop
    \begin{cppcode}
      std::vector<int> v;
      for(it = v.begin(); it != v.end(); it++) {...}
      int a[] = {1,2,3};
      for(i = 0; i < 3; i++) {...}
    \end{cppcode}
  \end{alertblock}
  \pause
  \begin{block}{The new syntax}
    \begin{cppcode}
      std::vector<int> v;
      for(it = begin(v); it != end(v); it++) {...}
      int a[] = {1,2,3};
      for(i = begin(a); i != end(a); i++) {...}
    \end{cppcode}
  \end{block}
\end{frame}

\subsection[Init]{Initializers}

\begin{frame}[fragile]
  \frametitle{Initializers}
  \begin{block}{\cpp98 nightmare}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=6}
        struct A {
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \begin{cppcode*}{gobble=6,firstnumber=6}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \pause
    \begin{cppcode*}{firstnumber=10}
     A a(1,2);       // A::A(int, int)
     A a(1);         // A::A(int)
     A a();          // declaration of a function !
     A a;            // A::A()
     B b = {1, 2.3}; // OK
     A a = {1,2};    // not allowed
     int ip[3] = {1,2,3};         // OK
     int* ip = new int[3]{1,2,3}; // not allowed;
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initializers}
  \begin{block}{\cpp11 uniformization}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=6}
        struct A {
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \begin{cppcode*}{gobble=6,firstnumber=6}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \pause
    \begin{cppcode*}{firstnumber=10}
     A a{1,2};       // A::A(int, int)
     A a{1};         // A::A(int)
     A a{};          // A::A()
     A a;            // A::A()
     B b = {1, 2.3}; // OK
     A a = {1,2};    // OK, A::A(int, int)
     int ip[3] = {1,2,3};         // OK
     int* ip = new int[3]{1,2,3}; // OK
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection{Lambdas}

\begin{frame}[fragile]
  \frametitle{Function return type}
  \begin{block}{A new way to specify function's return type}
    \begin{cppcode*}{linenos=false}
      ReturnType fn_name(ArgType1, ArgType2);  //old
      auto fn_name(ArgType1, ArgType2) -> ReturnType;
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{Advantages}
    \begin{itemize}
    \item Allows to simplify inner type definition
      \begin{cppcode*}{linenos=false,gobble=8}
        class TheClass {
          typedef int inner_type;
          inner_type func();
        }
        TheClass::inner_type TheClass::func() {...}
        auto TheClass::func() -> inner_type {...}
      \end{cppcode*}
    \item will be used for lambdas
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Lambdas}
  \begin{block}{Definition}
    a lambda is a function with no name
  \end{block}
  \pause
  \begin{exampleblock}{Python example}
    \begin{pythoncode*}{}
      data = [1,9,3,8,3,7,4,6,5]

      # without lambdas
      def isOdd(n):
        return n%2 == 0
      print filter(isOdd, data)

      # with lambdas
      print filter(lambda n:n>5, data)
    \end{pythoncode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp Lambdas}
  \begin{block}{Simplified syntax}
    \begin{cppcode*}{gobble=6}
      [] (args) -> type {
        code;
      }
    \end{cppcode*}
    The type specification is optionnal
  \end{block}
  \begin{exampleblock}{Usage example}
    \begin{cppcode*}{gobble=6}
      std::vector<int> data{1,2,3,4,5};
      for_each(begin(data), end(data),
               [](int i) {
                 std::cout << "The square of " << i
                           << " is " << i*i << std::endl;
               });
    \end{cppcode*}
  \end{exampleblock}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Capture}
  \begin{block}{Python code}
    \begin{pythoncode*}{}
      increment = 3
      data = [1,9,3,8,3,7,4,6,5]
      map(lambda x : x + increment, data)
    \end{pythoncode*}
  \end{block}
  \pause
  \begin{block}{First attempt in \cpp}
    \begin{cppcode}
      int increment = 4;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
               [](int x) { std::cout << x+increment; });
      std::cout << std::endl;
    \end{cppcode}
  \end{block}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=6]{text}
        error: 'increment' is not captured
          [](int x) { std::cout << x+increment; });
                                     ^
    \end{minted}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture}
  \begin{block}{Variable capture}
    \begin{itemize}
    \item external variables need to be explicitely captured
    \item captured variables are listed within initial []
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example}
    \begin{cppcode*}{gobble=6}
      int increment = 4;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
               [increment](int x) {
                 std::cout << x+increment;
               });
      std::cout << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Default capture is by value}
  \begin{exampleblock}{Code example}
    \begin{cppcode}
      int sum = 0;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [sum](int x) { sum += x; });
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=6]{text}
      error: assignment of read-only variable 'sum'
               [sum](int x) { sum += x; });
    \end{minted}
  \end{alertblock}
  \pause
  \begin{block}{Explanation}
    By default, variables are captured by value
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture by reference}
  \begin{exampleblock}{Simple example}
    In order to capture by reference, add '\&' before the variable
    \begin{cppcode}
      int sum = 0;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [&sum](int x) { sum += x; });
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Mixed case}
    One can of course mix values and references
    \begin{cppcode}
      int sum = 0, offset = 1;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [&sum, offset](int x) {
                sum += x + offset;
              });
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture all}
  \begin{block}{by value}
    \begin{cppcode*}{linenos=false}
      [=](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{by reference}
    \begin{cppcode*}{linenos=false}
      [&](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{exceptions}
    \begin{cppcode*}{linenos=false}
      [&, b](...) { ... };
      [=, &b](...) { ... };
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Closures}
  \begin{exampleblock}{Example}
    \begin{cppcode*}{gobble=6}
      auto build_incrementer = [](int inc) {
        return [inc](int value) { return value + inc; };
      };
      auto inc1 = build_incrementer(1);
      auto inc10 = build_incrementer(10);
      int i = 0;
      inc1(i);   // i = 1
      inc10(i);  // i = 11
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{How it works}
    \begin{itemize}
      \item build\_incrementer returns a function object
      \item this function's behavior depends on a parameter
      \item note how {\it auto} is useful here !
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp11 makes the STL usable}
  \begin{block}{Before lambdas}
    \begin{cppcode*}{gobble=6}
      struct Incrementer {
        int m_inc;
        Incrementer(int inc) : m_inc(inc) {}
        int operator() (int value) {
          return value + m_inc;
        };
      };
      std::vector<int> v;
      v.push_back(1); v.push_back(2); v.push_back(3); 
      std::transform(v.begin(), v.end(), v.begin(),
                     Incrementer(1));
      for (std::vector<int>::iterator it = v.begin();
           it != v.end();
           it++) std::cout << *it << " ";
      \end{cppcode*}
    \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp11 makes the STL usable}
  \begin{exampleblock}{With lambdas}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v = {1, 2, 3};
      int inc = 1;
      std::transform(v.begin(), v.end(), v.begin(),
                     [inc](int value) {
                       return value + inc;
                     });
      for (auto a : v) std::cout << a << " ";
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Conclusion}
    Use the STL !
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lambdas}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/lambdas
    \item look at the code (it's the solution to the stl exercise)
    \item use lambdas to simplify it
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection[Move]{Move semantic}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Non efficient code}
    \begin{cppcode*}{gobble=6}
      template <class T>
      void swap(T &a, T &b) {
        T c = a;
        a = b;
        b = c;
      }
      std::vector<int> v, w;
      for (int i = 0; i < 10000; i++) v.push_back(i);
      for (int i = 0; i < 10000; i++) w.push_back(i);
      swap(v, w);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What really happens during swap}
    \begin{itemize}
    \item 30k allocations + 30k releases
    \item 30k copies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Dedicated efficient code}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v, w;
      for (int i = 0; i < 10000; i++) v.push_back(i);
      for (int i = 0; i < 10000; i++) w.push_back(i);
      v.swap(w);
      \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{What probably happens during swap}
    \begin{itemize}
    \item 3 allocations + 3 releases
    \item 3 copies
    \end{itemize}
    only the pointers to underlying arrays were swapped
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Another non efficient code}
    \begin{cppcode*}{gobble=6}
      std::vector<int> vrandom(unsigned int n) {
        std::vector<int> result;
        for (int i = 0; i < n; i++) {
          result.push_back(rand());
        }
        return result;
      }
      std::vector<int> v = vrandom(10000);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What really happens during assignement}
    \begin{itemize}
    \item 10k allocations + 10k releases
    \item 10k copies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Dedicated efficient way}
    \begin{cppcode*}{gobble=6}
      void vrandom(unsigned int n, std::vector<int> &v) {
        for (int i = 0; i < n; i++) {
          v.push_back(rand());
        }
      }
      std::vector<int> v;
      vrandom(10000, v);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{The ideal situation}
    Have a way to express that we move the vector's content
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{The idea}
    \begin{itemize}
      \item a new type of reference : rvalue references
      \begin{itemize}
      \item used for move semantic
      \item denoted by \&\&
      \end{itemize}
      \item 2 new members in every class, with move semantic :
      \begin{description}
      \item[a move constructor] similar to copy constructor
      \item[a move assignement operator] similar to assignement operator (now called copy assignement operator)
      \end{description}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{gobble=6}
      T(const T&  other); // copy construction
      T(      T&& other); // move construction
      T& operator=(const T&  other); // copy assignment
      T& operator=(      T&& other); // move assignment
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{A few important points concerning move semantic}
    \begin{itemize}
    \item the whole STL can understand the move semantic
    \item move assignement operator is allowed to destroy source
      \begin{itemize}
      \item so do not reuse source afterward
      \item still, I advice to never leave inconsistent objects
      \end{itemize}
    \item if not implemented, move falls back to copy version
    \item move is called by the compiler whenever possible
      \begin{itemize}
      \item e.g. when passing temporary
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{gobble=6}
      T a;
      T b = a;      // 1. Copy assign
      T c = T(2);   // 2. Move assign
      T d = func(); // 3. Move assign
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{In some cases, you want to force a move}
    \begin{cppcode*}{gobble=6}
      template <class T> void swap(T &a, T &b) {
        T c = a;  // copy
        a = b;    // copy
        b = c;    // copy
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{There are mainly two ways}
    \begin{itemize}
    \item casting to an rvalue reference
    \item using the std::move function
    \end{itemize}
    \begin{cppcode*}{gobble=6}
      T a;
      T b = a;                   // 1. Copy assign
      T c = std::move(a);        // 4. Move assign
      T d = static_cast<T&&>(a); // 5. Move assign
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Diversion : constructor delegation}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid replication of code in several constructors
    \item by delegating to another constructor, in the initializer list
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Delegate {
        Delegate() { ... complex initialization ...};
        Delegate(int i) : Delegate(), m_i(i) {};
      }
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the easy way}
  \begin{block}{Use copy and swap idiom}
    \begin{itemize}
    \item implement an efficient swap method to your class
      \begin{itemize}
      \item preferably outside the class so that it is symetric
      \end{itemize}
    \item use swap for move constructor
      \begin{itemize}
      \item create empty object with constructor delegation
      \item swap it with source
      \end{itemize}
    \item use swap in move assignment
      \begin{itemize}
      \item pass parameter by value
      \item this should force creation of a local replica of source
      \item as we are in the move assignement \\
        our move constructor will be called \\
        and source will be filled with an empty object
      \item swap local object with *this
      \item let local object be destructed when exiting the method \\
        this will actually destroy the original content of the target
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the easy way}
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{gobble=6}
      class Movable {
        Movable();
        Movable(Movable &&other) :
          Movable() {         // constructor delegation
          swap(*this, other);
        }
        Movable& operator=(Movable other) { // by value
          swap(*this, other);
          return *this;
        }
        friend void swap(Movable &a, Movable &b);        
      };
      void swap(Movable &a, Movable &b);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move Semantic}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/move
    \item look at the code and run it with callgrind
    \item understand how inefficient it is
    \item implement move semantic the easy way in NVector
    \item run with callgrind and see no improvement
    \item understand why and fix test.cpp
    \item see efficiency improvements
    \end{itemize}
  \end{alertblock}
\end{frame}
