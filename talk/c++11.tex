\section[C$^{++}$11]{C$^{++}$11 and C$^{++}$14 preview}

\iffalse
\subsection[Intro]{Introduction}

\begin{frame}
  \frametitle{Introduction to \cpp11 and \cpp14}
  \begin{block}{status}
    \begin{itemize}
    \item Latest \cpp specifications
    \item Not yet digested by most programmers
    \item Bringing a lot of goodies
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{How to use \cpp11 features}
    \begin{itemize}
    \item Use a compatible compiler gcc $\geq$ 4.8, clang $\geq$ 3.3
    \item add -std=c++11 to compilation flags
    \end{itemize}    
  \end{block}
  \begin{block}{How to use \cpp14 features}
    \begin{itemize}
    \item Use a compatible compiler gcc $\geq$ 4.9, clang $\geq$ 3.4
    \item add -std=c++14 to compilation flags
    \end{itemize}    
  \end{block}
\end{frame}

\subsection[loop]{Range based loops}

\begin{frame}[fragile]
  \frametitle{Range based loops}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item simplifies loops tremendously
    \item especially with STL containers
    \end{itemize}
  \end{block}
  \begin{block}{Syntax}
    \begin{cppcode*}{linenos=false}
      for ( type iteration_variable : container ) {
        // body using iteration_variable
      }
    \end{cppcode*}
  \end{block}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      int sum = 0;
      for (int a : v) { sum += a; }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[auto]{auto keyword}

\begin{frame}[fragile]
  \frametitle{Auto keyword}
  \begin{block}{Reason of being}
    \begin{itemize}
    \item many type declarations are redundant
    \item and lead to compiler error if you mess up
    \end{itemize}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      int a = v[3];
      int b = v.size();  // bug ? unsigned to signed
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{New way}
    \begin{cppcode*}{linenos=false}
      std::vector<int> v;
      auto a = v[3];
      auto b = v.size();
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Loops and auto keyword with the STL}
  \begin{block}{Old way}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v;
      int sum = 0;
      for (std::vector<int>::iterator it = a.begin();
           it != a.end();
           it++) {
        sum += *it;
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{New way}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v;
      int sum = 0;
      for (auto a : v) { sum += a; }
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[begin]{non-member begin/end}

\begin{frame}[fragile]
  \frametitle{non-member begin and end}
  \begin{alertblock}{The problem}
    STL containers and arrays have different syntax for loop
    \begin{cppcode}
      std::vector<int> v;
      for(it = v.begin(); it != v.end(); it++) {...}
      int a[] = {1,2,3};
      for(i = 0; i < 3; i++) {...}
    \end{cppcode}
  \end{alertblock}
  \pause
  \begin{block}{The new syntax}
    \begin{cppcode}
      std::vector<int> v;
      for(it = begin(v); it != end(v); it++) {...}
      int a[] = {1,2,3};
      for(int* i = begin(a); i != end(a); i++) {...}
    \end{cppcode}
  \end{block}
\end{frame}

\subsection[init]{Initializers}

\begin{frame}[fragile]
  \frametitle{Initializers - objects}
  \begin{block}{\cpp98 nightmare}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=6}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=6,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \pause
    \begin{cppcode*}{firstnumber=12}
     A a(1,2);       // A::A(int, int)
     A a(1);         // A::A(int)
     A a();          // declaration of a function !
     A a;            // A::A()
     B b = {1, 2.3}; // OK
     A a = {1,2};    // not allowed
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initializers - objects}
  \begin{block}{\cpp11 uniformization}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=6}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=6,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \begin{cppcode*}{firstnumber=12}
     A a{1,2};       // A::A(int, int)
     A a{1};         // A::A(int)
     A a{};          // A::A()
     A a;            // A::A()
     B b = {1, 2.3}; // OK
     A a = {1,2};    // OK, A::A(int, int)
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initializers - arrays and vectors}
  \begin{block}{\cpp98 nightmare}
    \begin{cppcode*}{firstnumber=10}
     int ip[3] = {1,2,3};          // OK
     int* ip = new int[3]{1,2,3};  // not allowed
     std::vector<int> v = {1,2,3}; // not allowed
    \end{cppcode*}
  \end{block}
  \pause
  \begin{exampleblock}{\cpp11 uniformization}
    \begin{cppcode*}{firstnumber=10}
     int ip[3] = {1,2,3};          // OK
     int* ip = new int[3]{1,2,3};  // OK
     std::vector<int> v = {1,2,3}; // OK
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[$\lambda$]{Lambdas}

\begin{frame}[fragile]
  \frametitle{Function return type}
  \begin{block}{A new way to specify function's return type}
    \begin{cppcode*}{linenos=false}
      ReturnType fn_name(ArgType1, ArgType2);  //old
      auto fn_name(ArgType1, ArgType2) -> ReturnType;
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{Advantages}
    \begin{itemize}
    \item Allows to simplify inner type definition
      \begin{cppcode*}{linenos=false,gobble=8}
        class TheClass {
          typedef int inner_type;
          inner_type func();
        }
        TheClass::inner_type TheClass::func() {...}
        auto TheClass::func() -> inner_type {...}
      \end{cppcode*}
    \item will be used for lambdas
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Lambdas}
  \begin{block}{Definition}
    a lambda is a function with no name
  \end{block}
  \pause
  \begin{exampleblock}{Python example}
    \begin{pythoncode*}{}
      data = [1,9,3,8,3,7,4,6,5]

      # without lambdas
      def isOdd(n):
        return n%2 == 0
      print filter(isOdd, data)

      # with lambdas
      print filter(lambda n:n>5, data)
    \end{pythoncode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp Lambdas}
  \begin{block}{Simplified syntax}
    \begin{cppcode*}{gobble=6}
      [] (args) -> type {
        code;
      }
    \end{cppcode*}
    The type specification is optionnal
  \end{block}
  \begin{exampleblock}{Usage example}
    \begin{cppcode*}{gobble=6}
      std::vector<int> data{1,2,3,4,5};
      for_each(begin(data), end(data),
               [](int i) {
                 std::cout << "The square of " << i
                           << " is " << i*i << std::endl;
               });
    \end{cppcode*}
  \end{exampleblock}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Capture}
  \begin{block}{Python code}
    \begin{pythoncode*}{}
      increment = 3
      data = [1,9,3,8,3,7,4,6,5]
      map(lambda x : x + increment, data)
    \end{pythoncode*}
  \end{block}
  \pause
  \begin{block}{First attempt in \cpp}
    \begin{cppcode}
      int increment = 4;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
               [](int x) { std::cout << x+increment; });
      std::cout << std::endl;
    \end{cppcode}
  \end{block}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=6]{text}
        error: 'increment' is not captured
          [](int x) { std::cout << x+increment; });
                                     ^
    \end{minted}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture}
  \begin{block}{Variable capture}
    \begin{itemize}
    \item external variables need to be explicitely captured
    \item captured variables are listed within initial []
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example}
    \begin{cppcode*}{gobble=6}
      int increment = 4;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
               [increment](int x) {
                 std::cout << x+increment;
               });
      std::cout << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Default capture is by value}
  \begin{exampleblock}{Code example}
    \begin{cppcode}
      int sum = 0;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [sum](int x) { sum += x; });
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=6]{text}
      error: assignment of read-only variable 'sum'
               [sum](int x) { sum += x; });
    \end{minted}
  \end{alertblock}
  \pause
  \begin{block}{Explanation}
    By default, variables are captured by value
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture by reference}
  \begin{exampleblock}{Simple example}
    In order to capture by reference, add '\&' before the variable
    \begin{cppcode}
      int sum = 0;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [&sum](int x) { sum += x; });
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Mixed case}
    One can of course mix values and references
    \begin{cppcode}
      int sum = 0, offset = 1;
      std::vector<int> data{1,9,3,8,3,7,4,6,5};
      for_each(begin(data), end(data),
              [&sum, offset](int x) {
                sum += x + offset;
              });
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capture all}
  \begin{block}{by value}
    \begin{cppcode*}{linenos=false}
      [=](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{by reference}
    \begin{cppcode*}{linenos=false}
      [&](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{exceptions}
    \begin{cppcode*}{linenos=false}
      [&, b](...) { ... };
      [=, &b](...) { ... };
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Closures}
  \begin{exampleblock}{Example}
    \begin{cppcode*}{gobble=6}
      auto build_incrementer = [](int inc) {
        return [inc](int value) { return value + inc; };
      };
      auto inc1 = build_incrementer(1);
      auto inc10 = build_incrementer(10);
      int i = 0;
      inc1(i);   // i = 1
      inc10(i);  // i = 11
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{How it works}
    \begin{itemize}
      \item build\_incrementer returns a function object
      \item this function's behavior depends on a parameter
      \item note how {\it auto} is useful here !
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp11 makes the STL usable}
  \begin{block}{Before lambdas}
    \begin{cppcode*}{gobble=6}
      struct Incrementer {
        int m_inc;
        Incrementer(int inc) : m_inc(inc) {}
        int operator() (int value) {
          return value + m_inc;
        };
      };
      std::vector<int> v;
      v.push_back(1); v.push_back(2); v.push_back(3); 
      std::transform(v.begin(), v.end(), v.begin(),
                     Incrementer(1));
      for (std::vector<int>::iterator it = v.begin();
           it != v.end();
           it++) std::cout << *it << " ";
      \end{cppcode*}
    \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\cpp11 makes the STL usable}
  \begin{exampleblock}{With lambdas}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v = {1, 2, 3};
      int inc = 1;
      std::transform(v.begin(), v.end(), v.begin(),
                     [inc](int value) {
                       return value + inc;
                     });
      for (auto a : v) std::cout << a << " ";
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Conclusion}
    Use the STL !
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lambdas}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/lambdas
    \item look at the code (it's the solution to the stl exercise)
    \item use lambdas to simplify it
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection[mv]{Move semantic}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Non efficient code}
    \begin{cppcode*}{gobble=6}
      template <class T>
      void swap(T &a, T &b) {
        T c = a;
        a = b;
        b = c;
      }
      std::vector<int> v, w;
      for (int i = 0; i < 10000; i++) v.push_back(i);
      for (int i = 0; i < 10000; i++) w.push_back(i);
      swap(v, w);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What really happens during swap}
    \begin{itemize}
    \item 30k allocations + 30k releases
    \item 30k copies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Dedicated efficient code}
    \begin{cppcode*}{gobble=6}
      std::vector<int> v, w;
      for (int i = 0; i < 10000; i++) v.push_back(i);
      for (int i = 0; i < 10000; i++) w.push_back(i);
      v.swap(w);
      \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{What probably happens during swap}
    \begin{itemize}
    \item 3 allocations + 3 releases
    \item 3 copies
    \end{itemize}
    only the pointers to underlying arrays were swapped
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Another non efficient code}
    \begin{cppcode*}{gobble=6}
      std::vector<int> vrandom(unsigned int n) {
        std::vector<int> result;
        for (int i = 0; i < n; i++) {
          result.push_back(rand());
        }
        return result;
      }
      std::vector<int> v = vrandom(10000);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What really happens during assignment}
    \begin{itemize}
    \item 10k allocations + 10k releases
    \item 10k copies
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the problem}
  \begin{exampleblock}{Dedicated efficient way}
    \begin{cppcode*}{gobble=6}
      void vrandom(unsigned int n, std::vector<int> &v) {
        for (int i = 0; i < n; i++) {
          v.push_back(rand());
        }
      }
      std::vector<int> v;
      vrandom(10000, v);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{The ideal situation}
    Have a way to express that we move the vector's content
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{The idea}
    \begin{itemize}
      \item a new type of reference : rvalue references
      \begin{itemize}
      \item used for move semantic
      \item denoted by \&\&
      \end{itemize}
      \item 2 new members in every class, with move semantic :
      \begin{description}
      \item[a move constructor] similar to copy constructor
      \item[a move assignment operator] similar to assignment operator (now called copy assignment operator)
      \end{description}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{gobble=6}
      T(const T&  other); // copy construction
      T(      T&& other); // move construction
      T& operator=(const T&  other); // copy assignment
      T& operator=(      T&& other); // move assignment
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{A few important points concerning move semantic}
    \begin{itemize}
    \item the whole STL can understand the move semantic
    \item move assignment operator is allowed to destroy source
      \begin{itemize}
      \item so do not reuse source afterward
      \item still, I advice to never leave inconsistent objects
      \end{itemize}
    \item if not implemented, move falls back to copy version
    \item move is called by the compiler whenever possible
      \begin{itemize}
      \item e.g. when passing temporary
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{gobble=6}
      T a;
      T b = a;      // 1. Copy assign
      T c = T(2);   // 2. Move assign
      T d = func(); // 3. Move assign
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics}
  \begin{block}{In some cases, you want to force a move}
    \begin{cppcode*}{gobble=6}
      template <class T> void swap(T &a, T &b) {
        T c = a;  // copy
        a = b;    // copy
        b = c;    // copy
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{There are mainly two ways}
    \begin{itemize}
    \item casting to an rvalue reference
    \item using the std::move function
    \end{itemize}
    \begin{cppcode*}{gobble=6}
      T a;
      T b = a;                   // 1. Copy assign
      T c = std::move(a);        // 4. Move assign
      T d = static_cast<T&&>(a); // 5. Move assign
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Diversion : constructor delegation}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid replication of code in several constructors
    \item by delegating to another constructor, in the initializer list
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Delegate {
        Delegate() { ... complex initialization ...};
        Delegate(int i) : Delegate(), m_i(i) {};
      }
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the easy way}
  \begin{block}{Use copy and swap idiom}
    \begin{itemize}
    \item implement an efficient swap method to your class
      \begin{itemize}
      \item preferably outside the class so that it is symetric
      \end{itemize}
    \item use swap for move constructor
      \begin{itemize}
      \item create empty object with constructor delegation
      \item swap it with source
      \end{itemize}
    \item use swap in move assignment
      \begin{itemize}
      \item pass parameter by value
      \item this should force creation of a local replica of source
      \item as we are in the move assignment \\
        our move constructor will be called \\
        and source will be filled with an empty object
      \item swap local object with *this
      \item let local object be destructed when exiting the method \\
        this will actually destroy the original content of the target
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move semantics : the easy way}
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{gobble=6}
      class Movable {
        Movable();
        Movable(Movable &&other) :
          Movable() {         // constructor delegation
          swap(*this, other);
        }
        Movable& operator=(Movable other) { // by value
          swap(*this, other);
          return *this;
        }
        friend void swap(Movable &a, Movable &b);        
      };
      void swap(Movable &a, Movable &b);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Move Semantic}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/move
    \item look at the code and run it with callgrind
    \item understand how inefficient it is
    \item implement move semantic the easy way in NVector
    \item run with callgrind and see no improvement
    \item understand why and fix test.cpp
    \item see efficiency improvements
    \end{itemize}
  \end{alertblock}
\end{frame}

\fi

\subsection[RAII]{pointers and RAII}

\begin{frame}[fragile]
  \frametitle{nullptr}
  \begin{block}{Finally a \cpp~NULL pointer}
    \begin{itemize}
    \item works like 0 or NULL in standard cases
    \item triggers compilation error when mapped to integer
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      void* vp = nullptr;
      int* ip = nullptr;
      int i = NULL;      // OK -> bug ?
      int i = nullptr;   // ERROR
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pointers : why they are error prone ?}
  \begin{exampleblock}{They need initialization
      \hfill \onslide<2->{\textcolor{orange}{\bf Seg Fault}}}
    \begin{cppcode*}{linenos=false}
      char *s;
      try {
        foo();
        s = (char*) malloc(...);
        strncpy(s, ...);
      } catch (...) { ... }
      bar(s);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \pause
  \vspace{-2cm}
  \begin{exampleblock}{They need to be released
      \hfill \onslide<4->{\textcolor{orange}{\bf Memory leak}}}
    \begin{cppcode*}{linenos=false}
      char *s = (char*) malloc(...);
      strncpy(s, ...);
      if (0 != strncmp(s, ...)) return;
      foo(s);
      free(s);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \pause
  \vspace{-2cm}
  \begin{exampleblock}{They need clear ownership
      \hfill \onslide<6->{\textcolor{orange}{\bf Who should release ?}}}
    \begin{cppcode*}{linenos=false}
      char *s = (char*) malloc(...);
      strncpy(s, ...);
      someVector.push_back(s);
      someSet.add(s);
      std::thread t1(vecConsumer, someVector);
      std::thread t2(setConsumer, someSet);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{This problem exists for any resource}
  \begin{exampleblock}{For example with a file}
    \begin{cppcode*}{}
      try {
        FILE *handle = std::fopen(path, "r");
        if (0 == handle) { throw ... }
        if (std::fputs(str, handle) == EOF) {
          throw ...
        }
        fclose(handle);
      } catch (...) { ... }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Resource Acquisition Is Initialization}
  \begin{block}{Practically}
    Use object semantic to acquire/release resources
    \begin{itemize}
    \item wrap the resource inside an object
    \item acquire resource via object constructor
    \item release resource in destructor
    \item create this object on the stack so that it is automatically destructed when leaving the scope
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII in practice}
  \begin{exampleblock}{File class}
    \begin{cppcode*}{}
    class File {
    public:
      File(const char* filename) :
        m_file_handle(std::fopen(filename, "w+")) {
        if (m_file_handle == NULL) { throw ... }
      }
      ~File() { std::fclose(m_file_handle); }
      void write (const char* str) {
        if (std::fputs(str, m_file_handle) == EOF) {
          throw ...
        }
      }
    private:
      FILE* m_file_handle;
    };
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII usage}
  \begin{exampleblock}{Usage of File class}
    \begin{cppcode*}{}
      void log_function() {
        // file opening, aka resource acquisition
        File logfile("logfile.txt") ;

        // file usage
        logfile.write("hello logfile!") ;
 
        // file is automatically closed by the call to
        // its destructor, even in case of exception !
      }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{std::unique\_ptr}
  \begin{block}{an RAII pointer}
    \begin{itemize}
    \item wraps a regular pointer
    \item has move only semantic
      \begin{itemize}
      \item the pointer is only owned once
      \end{itemize}
    \item in \textless{}memory\textgreater{} header
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Usage}
    \begin{cppcode*}{}
      Foo *p = new Foo{};  // allocation
      std::unique_ptr<Foo> uptr(p);
      std::cout << uptr.get() << " points to "
                << uptr->someMember << std::endl;
      void f(std::unique_ptr<Foo> ptr);
      f(std::move(uptr)); // transfer of ownership
      // deallocation when exiting f
      std::cout << uptr.get() << std::endl; // 0
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quizz}
  \begin{exampleblock}{}
    \begin{cppcode*}{}
      Foo *p = new Foo{};  // allocation
      std::unique_ptr<Foo> uptr(p);
      void f(std::unique_ptr<Foo> ptr);
      f(uptr); // transfer of ownership
    \end{cppcode*}
    What do you expect ?
  \end{exampleblock}
  \pause
  \begin{alertblock}{Compilation Error}
    \begin{minted}{text}
test.cpp:15:5: error: call to deleted constructor
of 'std::unique_ptr<Foo>'
  f(uptr);
    ^~~~
/usr/include/c++/4.9/bits/unique_ptr.h:356:7: note: 
 'unique_ptr' has been explicitly marked deleted here
 unique_ptr(const unique_ptr&) = delete;
 ^
    \end{minted}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{std::make\_unique}
  \begin{block}{}
    \begin{itemize}
    \item allocates directly a unique\_ptr
    \item no new or delete calls anymore !
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{make\_unique usage}
    \begin{cppcode*}{}
      // allocation of one Foo object,
      // calling constructor with one argument
      auto a = std::make_unique<Foo>(memberValue);
      std::cout << a.get() << " points to "
                << a->someMember << std::endl;
      // allocation of an array of Foos
      // calling default constructor
      auto b = std::make_unique<Foo[]>(10);
      // deallocations
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII or raw pointers}
  \begin{block}{When to use what ?}
    \begin{itemize}
    \item Always use RAII for allocations
    \item You thus never have to deallocate !
    \item Use raw pointers for observer functions (or references)
      \begin{itemize}
      \item remember that unique\_ptr is move only
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{A question of ownership}
    \begin{cppcode*}{}
      unique_ptr<T> producer();
      void observer(T*);
      void consumer(unique_ptr<T>);

      unique_ptr<T> pt{producer()};
      observer(pt.get());       // Keep ownership
      consumer(std::move(pt));  // Transfer ownership
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{unique\_ptr usage summary}
  \begin{block}{It's about lifetime management}
    \begin{itemize}
    \item Use unique\_ptr in functions taking part to the lifetime management
    \item Otherwise use raw pointers or references
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{shared\_ptr, make\_shared}
  \begin{block}{shared\_ptr : a reference counting pointers}
    \begin{itemize}
    \item wraps a regular pointer like unique\_ptr
    \item has move and copy semantic
    \item uses internally reference counting
      \begin{itemize}
      \item "Would the last person out, please turn off the lights ?"
      \end{itemize}
    \item is thread safe, thus the reference counting is costly
    \end{itemize}
  \end{block}
  \begin{block}{make\_shared : creates a shared\_ptr}
    \begin{cppcode*}{}
      {
        auto sp = std::make_shared<Foo>(); // #ref = 1
        vector.push_back(sp);              // #ref = 2
        set.insert(sp);                    // #ref = 3
      } // #ref 2
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[thread]{Concurrency and asynchronicity}

\begin{frame}[fragile]
  \frametitle{Basic concurrency}
  \begin{block}{Threading}
    \begin{itemize}
    \item new object std::thread in \textless{}thread\textgreater{} header
    \item takes a function as argument of its constructor
    \item must be called on join or program is terminated
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      void doSth() {...};
      void doSthElse() {...};
      int main() {
        std::thread t1(doSth);
        std::thread t2(doSthElse);
        for (auto t: {&t1,&t2}) t->join();
      }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The thread constructor}
  \begin{exampleblock}{Can take a function and its arguments}
    \begin{cppcode*}{}
      void function(int j, double j) {...};
      std::thread t1(function, 1, 2.0);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Can take any function like object}
    \begin{cppcode*}{}
      struct AdderFunctor {
        AdderFunctor(int i): m_i(i) {}
        int operator() (int j) { return i+j; };
        int m_i;
      };
      std::thread t2(AdderFunctor(2), 5);
      int a;
      std::thread t3([](int i) { return i+2; }, a);
      std::thread t4([a]       { return a+2; });
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Basic asynchronicity}
  \begin{block}{Concept}
    \begin{itemize}
    \item separation of the specification of what should be done and the retrieval of the results
    \item ``start working on this, and ping me when it's ready''
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{Pratically}
    \begin{itemize}
    \item std::async function launches and asynchronous task
    \item std::future template allows to handle the result
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      int computeSth() {...}
      std::future<int> res = std::async(computeSth);
      std::cout << res->get() << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mixing the two}
  \begin{block}{Is async running concurrent code ?}
    \begin{itemize}
    \item it depends !
    \item you can control this with a launch policy argument
      \begin{description}
      \item[std::launch::async] spawns a thread for immediate execution
      \item[std::launch::deferred] causes lazy execution in current thread
      \end{description}
      \begin{itemize}
      \item execution starts when get() is called
      \end{itemize}
    \item default is not specified !
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Usage}
    \begin{cppcode*}{}
      int computeSth() {...}
      auto res = std::async(std::launch::async,
                            computeSth);
      auto res2 = std::async(std::launch::deferred,
                             computeSth);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fine grained control on asynchronous execution}
  \begin{block}{std::packaged\_task template}
    \begin{itemize}
    \item creates an asynchronous version of any function like object
      \begin{itemize}
      \item identical arguments
      \item returns a std::future
      \end{itemize}
    \item provides access to the returned future
    \item associated with threads, gives full control on execution
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Usage}
    \begin{cppcode*}{}
      int task() { return 42; }
      std::packaged_task<int()> pckd_task(task);
      auto future = pckd_task.get_future();
      pckd_task();
      std::cout << future.get() << std::endl;
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\subsection[mutex]{Mutexes}

\begin{frame}[fragile]
  \frametitle{Races}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      int a = 0;
      void inc() { a++; };
      void inc100() {
        for (int i=0; i < 100; i++) inc();
      };
      int main() {
        std::thread t1(inc100);
        std::thread t2(inc100);
        for (auto t: {&t1,&t2}) t->join();
        std::cout << a << std::endl;
      }
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{What do you expect ? Try it in code/race}
    \pause
    Anything between 100 and 200 !!!
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Atomicity}
  \begin{block}{Concept}
    \begin{itemize}
    \item property of an operation that in cannot be half executed
    \item either it's done, or not done at all
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Is ++ operator atomic ?}
    Usually not. It behaves like :
    \begin{cppcode*}{}
      eax = a       // memory to register copy
      increase eax  // increase (atomic CPU instruction)
      a = eax       // copy back to memory
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Timing}
  \begin{exampleblock}{Code}
    \begin{cppcode*}{}
      eax = a       // memory to register copy
      increase eax  // increase (atomic CPU instruction)
      a = eax       // copy back to memory
    \end{cppcode*}
  \end{exampleblock}
  \begin{block}{For 2 threads}
    \begin{tikzpicture}
      \begin{umlseqdiag}
        \umlobject[x=0, class=eax]{Thread 1}
        \umlobject[x=3, class=a, fill=blue!20]{Memory}
        \umlobject[x=6, class=eax]{Thread 2}
        \begin{umlcall}[op=read, type=synchron, return=0]{Thread 1}{Memory}
        \end{umlcall}
        \begin{umlcall}[padding=3, op=read, type=synchron, return=0]{Thread 2}{Memory}
        \end{umlcall}
        \begin{umlcallself}[op=incr, type=synchron]{Thread 1}
        \end{umlcallself}
        \begin{umlcallself}[op=incr, type=synchron]{Thread 2}
        \end{umlcallself}
        \begin{umlcall}[op=write 1]{Thread 2}{Memory}
        \end{umlcall}
        \begin{umlcall}[padding=3, op=write 1]{Thread 1}{Memory}
        \end{umlcall}
      \end{umlseqdiag}
      \draw[-triangle 60](8.5,0) -- (8.5,-4) node[right, pos=0.5]{time};
    \end{tikzpicture}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutexes}
  \begin{block}{Concept}
    \begin{itemize}
    \item a lock to serialize access to a non atomic piece of code
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{The objects}
    \begin{description}
    \item[std::mutex] in the mutex header
    \item[std::lock\_guard] for an RAII version of it
    \item[std::unique\_lock] same and can be released/relocked
    \end{description}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{}
      int a = 0;
      std::mutex m;
      void inc() {
        std::lock_guard<std::mutex> guard(m);
        a++;
      };
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dead lock}
  \begin{exampleblock}{Scenario}
    \begin{itemize}
    \item 2 locks, 2 threads
    \item locking order inverted in the 2 threads
    \end{itemize}
  \end{exampleblock}
  \pause
  \begin{block}{Sequence diagram}
    \begin{tikzpicture}
      \begin{umlseqdiag}
        \umlobject[x=0]{Thread 1}
        \umlobject[x=2.5, fill=blue!20]{Mutex A}
        \umlobject[x=5, fill=blue!20]{Mutex B}
        \umlobject[x=7.5]{Thread 2}
        \begin{umlcall}[op=lock]{Thread 1}{Mutex A}
        \end{umlcall}
        \begin{umlcall}[op=lock, dt=6]{Thread 2}{Mutex B}
        \end{umlcall}
        \begin{umlcall}[op=lock (block), dt=6]{Thread 1}{Mutex B}
        \end{umlcall} 
        \begin{umlcall}[op=lock (block), dt=12]{Thread 2}{Mutex A}
        \end{umlcall}
      \end{umlseqdiag}
      \draw[-triangle 60](9,0) -- (9,-4) node[right, pos=0.5]{time};
    \end{tikzpicture}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dead Lock}
  \begin{block}{Solutions}
    \begin{itemize}
    \item Do not take several locks
      \begin{itemize}
      \item Or add master lock protecting the locking phase
      \end{itemize}
    \item Respect a strict order in the locking in all threads
    \item Lock free programming
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Handling dependencies}
  \begin{block}{Condition variables}
    \begin{itemize}
    \item They allow a thread to sleep until a given condition is satisfied
    \item std::condition\_variable object from condition\_variable header
    \item works on top of an RAII guard on a mutex
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{How does it work}
    \begin{itemize}
    \item it uses a RAII lock around a mutex
    \item the wait() method releases the lock to run the check
    \item and takes it again once done
    \item check is done at construction and on call to notify\_*()
    \item several conditions can share the same mutex
    \item notify\_one will wake up a single one
    \item notify\_all() will wake up all
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Condition variable usage}
  \begin{exampleblock}{Example code}
    \begin{cppcode*}{}
      int value = -1;
      std::mutex mutex;
      std::condition cond;
      auto t = std::thread([] () {
        value = ... long proces ...;
        cond.notify_all();
      });
      auto t = std::thread([] () {
        std::unique_lock<std::mutex> lock{mutex};
        condition.wait(lock, [] { return value > 0; });
        ... use value ...
      });
      { std::unique_lock<std::mutex> lock{mutex};
        condition.wait(lock, [] { return value > 0; });
        std::cout << value << std::endl; }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}
