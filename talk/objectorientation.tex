\section[OO]{Object orientation (OO)}

\subsection[Objects]{Objects and Classes}

\begin{frame}[fragile]
  \frametitlegb{What are classes and objects}
  \begin{block}{Classes}
    structs on steroids
    \begin{itemize}
    \item with inheritance
    \item including methods
    \end{itemize}
  \end{block}
  \begin{block}{Objects}
    instances of classes
  \end{block}
  \begin{block}{A class encapsulates a concept}
    \begin{itemize}
    \item shows an interface
    \item provides its implementation
      \begin{itemize}
      \item status, properties
      \item possible interactions
      \item construction and destruction
      \end{itemize}    
    \end{itemize}    
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitlegb{My First Class}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      struct MyFirstClass {
        int a;
        void squareA() {
          a *= a;
        };
        int sum(int b) {
          return a + b;
        };
      };

      MyFirstClass myObj;
      myObj.a = 2;

      // let's square a
      myObj.squareA();
    \end{cppcode*}
    \columnbreak
    \center
    \null \vfill
    \begin{tikzpicture}
      \classbox{MyFirstClass}{
        int a; \\
        void squareA(); \\
        int sum(int b);
      }
    \end{tikzpicture}
    \vfill \null
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Separating the interface}
  \begin{block}{Header : MyFirstClass.hpp}
    \begin{cppcode*}{linenos=false}
      struct MyFirstClass {
        int a;
        void squareA();
        int sum(int b);
      };
    \end{cppcode*}
  \end{block}
  \begin{block}{Implementation : MyFirstClass.cpp}
    \begin{cppcode*}{linenos=false}
      #include "MyFirstClass.hpp"
      void MyFirstClass::squareA() {
        a *= a;
      };
      void MyFirstClass::sum(int b) {
        return a + b;
      };
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{A word on namespaces}
  \begin{itemize}
  \item Namespaces allow to segment your code to avoid name clashes
  \item They can be embedded to create hierarchies (separator is '::')
  \end{itemize}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      int a;
      namespace n {
        int a;   // no clash
      }      
      namespace p {
        int a;   // no clash
        namespace inner {
          int a; // no clash
        }
      }
      int f() {
        n::a = 2;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=14}
      namespace p {
        int f() {
          p::a = 2;
          a = 2;  //same as above
          p::inner::a = 4;
          inner::a = 4;
          n::a = 5;
        }
      }
      using namespace p::inner;
      int g() {
        a = 3; // using p::inner
      }
  \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitleit{Nested namespaces}
  Easier way to declare nested namespaces
  \begin{alertblock}{\cpp14}
    \begin{cppcode*}{}
      namespace A {
        namespace B {
          namespace C {
            //...
          }
        }
      }
    \end{cppcode*}
  \end{alertblock}
  \begin{exampleblock}{\cpp17}
    \begin{cppcode*}{}
      namespace A::B::C {
        //...
      }
    \end{cppcode*}    
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Implementing methods}
  \begin{block}{Standard practice}
    \begin{itemize}
    \item usually in .cpp, outside of class declaration
    \item using the class name as namespace
    \item when reference to the object is needed, use {\it this} keyword
    \end{itemize}
  \end{block}
  \begin{cppcode}
    void MyFirstClass::squareA() {
      a *= a;
    };

    int MyFirstClass::sum(int b) {
      int a = 0; // do not do that !
      a += this->a;
      a += b;
      return a;
    };
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Method overloading}
  \begin{block}{The rules in \cpp}
    \begin{itemize}
    \item overloading is authorized and welcome
    \item signature is part of the method identity
    \item but not the return code
    \end{itemize}
  \end{block}
  \begin{cppcode}
    struct MyFirstClass {
      int a;
      int sum(int b);
      int sum(int b, int c);
    }

    int MyFirstClass::sum(int b) { return a + b; };

    int MyFirstClass::sum(int b, int c) {
      return a + b + c;
    };
  \end{cppcode}
\end{frame}

\subsection{Inheritance}

\begin{frame}[fragile]
  \frametitlegb{First inheritance}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      struct MyFirstClass {
        int a;
        void squareA() { a *= a; };
      };
      struct MySecondClass :
        MyFirstClass {
        int b;
        int sum() { return a + b; };
      };

      MySecondClass myObj2;
      myObj2.a = 2;
      myObj2.b = 5;
      myObj2.squareA();
      int i = myObj2.sum(); // i = 9
    \end{cppcode*}
    \columnbreak
    \center
    \null \vfill
    \begin{tikzpicture}[node distance=2.5cm]
      \classbox{MyFirstClass}{
        int a; \\
        void squareA();
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        int b; \\
        int sum();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass);
    \end{tikzpicture}
    \vfill \null
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Managing access to class members}
  \begin{block}{{\it public} \color{white} / {\it private} keywords}
    \begin{description}
      \item[private] allows access only within the class
      \item[public] allows access from anywhere
    \end{description}
    \begin{itemize}
      \item Default is {\it private}
      \item A {\it struct} is a {\it class} where all members are public
    \end{itemize}
  \end{block}
  \pause
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      class MyFirstClass {
      public:
        void setA(int a);
        int getA();
        void squareA();
      private:
        int a;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=9}
      MyFirstClass obj;
      obj.a = 5;   // error !
      obj.setA(5); // ok
      obj.squareA();
      int b = obj.getA();
    \end{cppcode*}
    \pause
    \begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,colback=red!5!white,colframe=red!75!black]
      This breaks MySecondClass !
    \end{tcolorbox}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Managing access to class members(2)}
  \begin{block}{Solution is {\it protected} keyword}
    Gives access to classes inheriting from base class
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      class MyFirstClass {
      public:
        void setA(int a);
        int getA();
        void squareA();
      protected:
        int a;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=13}
      class MySecondClass :
        public MyFirstClass {
      public:
        int sum() {
          return a + b;
        };
      private:
        int b;
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Managing inheritance privacy}
  \begin{block}{Inheritance can be public, protected or private}
    It influences the privacy of inherited members for external code.\\
    The code of the class itself is not affected
    \begin{description}
    \item[public] privacy of inherited members remains unchanged
    \item[protected] inherited public members are seen as protected
    \item[private] all inherited members are seen as private \\
      this is the default if nothing is specified
    \end{description}
  \end{block}
  \pause
  \begin{block}{Net result for external code}
    \begin{itemize}
    \item only public members of public inheritance are accessible
    \end{itemize}
  \end{block}
  \begin{block}{Net result for grand child code}
    \begin{itemize}
    \item only public and protected members of public and protected parents are accessible
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Managing inheritance privacy - public}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {public};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=2}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // OK
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Managing inheritance privacy - protected}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {protected};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=2}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // Error
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Managing inheritance privacy - private}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {private};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=2}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // Error
        int c = pub;    // Error
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // Error
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Final class}
  \begin{block}{Idea}
    \begin{itemize}
    \item make sure you cannot inherit from a given class
    \item by declaring it final
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Base final {
        ...
      };
      struct Derived : Base { // compiler error
        ...
      };
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\subsection[Constructors]{Constructors/destructors}

\begin{frame}[fragile]
  \frametitlegb{Class Constructors and Destructors}
  \begin{block}{Concept}
    \begin{itemize}
    \item special functions building/destroying an object
    \item a class can have several constructors
    \item the constructors have the name of the class
    \item same for the destructor with a leading $\sim$
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      class MyFirstClass {
      public:
        MyFirstClass();
        MyFirstClass(int a);
        ~MyFirstClass();
        ...
      protected:
        int a;
      };
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=10}
      // note special notation for
      // initialization of members
      MyFirstClass() : a(0) {}
      
      MyFirstClass(int a_):a(a_) {}

      ~MyFirstClass(){};
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlegb{Class Constructors and Destructors}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      ~Vector();
      void setN(int n, int value);
      int getN(int n);
    private:
      int len;
      int* data;
    }
    Vector::Vector(int n) : len(n) {
      data = (int*)malloc(n*sizeof(int));
    }
    Vector::~Vector() {
      free(data);
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Constructor and inheritance}
  \begin{cppcode}
    struct MyFirstClass {
      MyFirstClass();
      MyFirstClass(int a);
    }

    struct MySecondClass : MyFirstClass {
      MySecondClass();
      MySecondClass(int b);
      MySecondClass(int a, int b);
    }

    MySecondClass() : MyFirstClass(), b(0) {};
    MySecondClass(int b_) : MyFirstClass(), b(b_) {};
    MySecondClass(int a_,
                  int b_) : MyFirstClass(a_), b(b_) {};
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Copy constructor}
  \begin{block}{Concept}
    \begin{itemize}
    \item special constructor called for replicating an object
    \item takes a single parameter of type const ref to class
    \item will be implemented by the compiler if not provided
    \item in order to forbid copy, use {\texttt delete} (coming in 2 slides)
      \begin{itemize}
      \item or private copy constructor with no implementation in \cpp98
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    struct MySecondClass : MyFirstClass {
      MySecondClass();
      MySecondClass(const MySecondClass &other);
    }    
  \end{cppcode}
  \pause
  \begin{exampleblock}{The rule of 3/5 (\cpp98/\cpp11)}
    \begin{itemize}
    \item if a class has a destructor, a copy/move constructor or a (move) assignment operator, it should have all three/five
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Class Constructors and Destructors}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      Vector(const Vector &other);
      ~Vector();
      ...
    }
    Vector::Vector(int n) : len(n) {
      data = (int*)calloc(n, sizeof(int));
    }
    Vector::Vector(const Vector &other) : len(other.len) {
      data = (int*)malloc(len*sizeof(int));
      memcpy(data, other.data, len);
    }
    Vector::~Vector() { free(data); }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Default Constructor}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid writing explicitely default constructors
    \item by declaring them as default
    \end{itemize}
  \end{block}
  \begin{block}{Details}
    \begin{itemize}
    \item when no user defined constructor, a default is provided
    \item any user defined constructor disables default ones
    \item but they can be enforced.
    \item rule can be more subtle depending on members
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      ClassName() = default;  // provide/force default
      ClassName() = delete;   // do not provide default
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Constructor delegation}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid replication of code in several constructors
    \item by delegating to another constructor, in the initializer list
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Delegate {
        int m_i;
        Delegate() { ... complex initialization ...};
        Delegate(int i) : Delegate(), m_i(i) {};
      }
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Constructor inheritance}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid declaring empty constructors inheriting parent's ones
    \item by stating that we inherit all parent constructors
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct BaseClass {
        BaseClass(int value);
      };
      struct DerivedClass : BaseClass {
        using BaseClass::BaseClass;
      };
      DerivedClass a{5};
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Member initialization}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid redefining same default value for members n times
    \item by defining it once at member declaration time
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct BaseClass {
        int a{5};
        BaseClass() = default;
        BaseClass(int _a) : a(_a) {};
      };
      struct DerivedClass : BaseClass {
        int b{6};
        using BaseClass::BaseClass;
      };
      DerivedClass a{7}; // a = 7, b = 6
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Calling contructors}
  \begin{block}{After object declaration, arguments within \{\}}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=4}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=4,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \begin{cppcode*}{gobble=2, firstnumber=12}
      A a{1,2};       // A::A(int, int)
      A a{1};         // A::A(int)
      A a{};          // A::A()
      A a;            // A::A()
      A a = {1,2};    // A::A(int, int)
      B b = {1, 2.3}; // default constructor
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Calling constructors the old way}
  \begin{block}{Arguments are given within (), aka \cpp98 nightmare}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=4}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=4,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \begin{cppcode*}{gobble=2, firstnumber=12}
      A a(1,2);       // A::A(int, int)
      A a(1);         // A::A(int)
      A a();          // declaration of a function !
      A a;            // A::A()
      A a = {1,2};    // not allowed
      B b = {1, 2.3}; // OK
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[Static]{Static members}

\begin{frame}[fragile]
  \frametitlegb{Static members}
  \begin{block}{Concept}
    \begin{itemize}
    \item members attached to a class rather than to an object
    \item usable with or without an instance of the class
    \item identified by the {\it static} keyword
    \end{itemize}
  \end{block}
  \begin{cppcode}
    class Text {
    public:
      static std::string upper(std::string) {...};
    private:
      static int s_nbCallsToUpper;
    };
    int Text::s_nbCallsToUpper = 0;
    std::string s = "my text";
    std::string uppers = Text::upper("my text");
    // now Text::s_nbCallsToUpper is 1
  \end{cppcode}
\end{frame}

\subsection[New]{Allocating objects}

\begin{frame}[fragile]
  \frametitlegb{Process memory organization}
  \begin{block}{4 main areas}
    \begin{description}
    \item[the code segment] for the code of the executable
    \item[the data segment] for global variables
    \item[the heap] for dynamically allocated variables
    \item[the stack] for parameters of functions and local variables
    \end{description}
  \end{block}
  \hspace{2.5cm}
  \begin{tikzpicture}
    \memorystack[size x=5cm,word size=1,nb blocks=6,addresses=0]
    \memorypush{code segment}
    \memorypush{data segment}
    \memorypush{stack}
    \memorypush{...}
    \memorypush{...}
    \memorypush{heap}
    \draw[->] (stack3-1.north) ++(-1cm,0) -- +(0,.3cm);
    \draw[->] (stack3-1.north) ++(1cm,0) -- +(0,.3cm);
    \draw[->] (stack6-1.south) ++(-1cm,0) -- +(0,-.3cm);
    \draw[->] (stack6-1.south) ++(1cm,0) -- +(0,-.3cm);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{The Stack}
  \begin{block}{Main characteristics}
    \begin{itemize}
    \item allocation on the stack stays valid for the duration of the current scope.
    It is destroyed when it is popped off the stack.
    \item memory allocated on the stack is known at compile time and can thus be accessed through a variable.
    \item the stack is relatively small, it is not a good idea to allocate large arrays, structures or classes
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Object allocation on the stack}
  \begin{block}{On the stack}
    \begin{itemize}
    \item object are created when declared (constructor called)
    \item object are destructed when out of scope (destructor is called)
    \end{itemize}
  \end{block}
  \begin{cppcode}
    int f() {
      MyFirstClass a{3}; // constructor called
      ...
    } // destructor called

    {
      MyFirstClass a; // default constructor called
      ...
    }  // destructor called
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{The Heap}
  \begin{block}{Main characteristics}
    \begin{itemize}
    \item Allocated memory stays allocated until it is specifically deallocated
      \begin{itemize}
      \item beware memory leaks
      \end{itemize}
    \item Dynamically allocated memory must be accessed through pointers
    \item large arrays, structures, or classes should be allocated here
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Object allocation on the heap}
  \begin{block}{On the heap}
    \begin{itemize}
    \item object are created by calling {\it new} (constructor is called)
    \item object are destructed by calling {\it delete} (destructor is called)
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      // default constructor called
      MyFirstClass *a = new MyFirstClass;
      ...
      delete a; // destructor is called
    }

    int f() {
      // constructor called
      MyFirstClass *a = new MyFirstClass(3);
      ...
    } // memory leak !!!
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Array allocation on the heap}
  \begin{block}{Arrays on the heap}
    \begin{itemize}
    \item arrays of objects are created by calling {\it new[]} \\
      default constructor is called for each object of the array
    \item arrays of object are destructed by calling {\it delete[]} \\
      destructor is called for each object of the array
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      // default constructor called 10 times
      MyFirstClass *a = new MyFirstClass[10];
      ...
      delete[] a; // destructor called 10 times
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Back to calling constructors - arrays and vectors}
  \begin{exampleblock}{list of items given within \{\}}
    \begin{cppcode*}{firstnumber=10}
     int ip[3]{1,2,3};
     int* ip = new int[3]{1,2,3};
     std::vector<int> v{1,2,3};
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{\cpp98 nightmare}
    \begin{cppcode*}{firstnumber=10}
     int ip[3]{1,2,3};            // OK
     int* ip = new int[3]{1,2,3}; // not allowed
     std::vector<int> v{1,2,3};   // not allowed
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[Exceptions]{Exceptions}

\begin{frame}[fragile]
  \frametitlegb{Exceptions}
  \begin{block}{The concept}
    \begin{itemize}
    \item exceptional Event breaking linearity of the code
    \item will be handled in dedicated place
    \end{itemize}
  \end{block}
  \begin{block}{Pratically}
    \begin{itemize}
    \item you can throw any object with {\it throw}
    \item you handle them using {\it try ... catch} blocks
    \end{itemize}
  \end{block}
  \begin{cppcode}
    try {
      if (0 == name) {
        throw std::string("Expected non empty name");
      }
      printf("%s\n", name);
    } catch (std::string e) {
      printf("empty name found\n");      
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Exceptions}
  \begin{block}{Rules}
    \begin{itemize}
    \item exception will skip all code until next {\it catch}
    \begin{itemize}
      \item still destructors are called when exiting scopes
      \item but your own cleanup may not be
    \end{itemize}
    \item {\it catch} is selective on the exception type
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2}
      class ZeroDivide {};
      
      int divide(int a, int b) {
        if (0 == b) {
          throw ZeroDivide();
        }
        return a/b;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\scriptsize,gobble=2,firstnumber=9} 
      int func(char* value) {
        try {
          errno = 0;
          long l = strtol(value,0,10);
          if (errno) {
            throw string("Bad Value");
          }
          divide(100, l);
        } catch (string e) {
          printf("%s\n", e.c_str());
        } catch (ZeroDivide e2) {
          printf("Division error\n");
        }
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlegb{Controlling exceptions \hfill \deprecated}
  \begin{block}{Declaring expected exceptions}
    \begin{itemize}
    \item each function can declare a set of expected exceptions
    \item using the {\it throw} statement in its declaration
    \item other exceptions won't exit the scope of the function
      \begin{itemize}
      \item instead, the {\it unexpected} handler is called
      \item by default, it terminates the program
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    int func(int a) throw(int) {
      if (0 == a) {
        throw 2;  // ok, goes out
      } else {
        throw "hello"; // std::unexpected called
      }
    }
  \end{cppcode}
\end{frame}  

\begin{frame}[fragile]
  \frametitlegb{Controlling exceptions \hfill \deprecated}
  \begin{block}{Good to know}
    \begin{itemize}
    \item The check in done at runtime, not at compile time
      \begin{itemize}
      \item unlike Java
      \end{itemize}
    \item When the {\it throw} clause is absent, any exception can go out
    \item To block all exceptions, use {\it throw()}
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    int func(int a) {
      // any exception can go out
    }
    int otherfunc(int a) throw() {
      // no exception can go out
    }
  \end{cppcode}
\end{frame}  

\begin{frame}[fragile]
  \frametitleii{Deprecation of \cpp98 exceptions}
  \begin{block}{}
    After a lot of thinking and experiencing, the conclusions of the community on exception handling are :
    \begin{itemize}
    \item Never write an exception specification
    \item Except possibly an empty one
    \end{itemize}
  \end{block}
  \pause
  \begin{alertblock}{Some of the reasons}
    \begin{itemize}
    \item throw specification is runtime only
      \begin{itemize}
      \item does not allow compiler optimizations
      \item on the contrary forces extra checks
      \item generally terminates your program if violated
      \end{itemize}
    \item throw specification clashes with templates
      \begin{itemize}
      \item one cannot ``template'' the throw clause
      \end{itemize}
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{What remains}
  \begin{block}{throw is dead}
    \begin{itemize}
    \item throw statements are deprecated
    \item even throw() (no exceptions)
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{long live noexcept}
    \begin{itemize}
    \item noexcept a somehow equivalent to throw()
    \item but is checked at compile time
    \item so allows compiler optimizations
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitleii{Full power of noexcept}
  \begin{block}{3 uses of noexcept}
    \begin{itemize}
    \item standalone
      \begin{cppcode*}{gobble=2, linenos=false}
        int f() noexcept;
      \end{cppcode*}
    \item as an expression saying whether exceptions can be sent
      \begin{cppcode*}{gobble=2, linenos=false}
        int f() noexcept(sizeof(long) == 8);
      \end{cppcode*}
    \item as an operator to know whether a function launches exceptions
      \begin{cppcode*}{gobble=2, linenos=false}
        template <class T> void foo()
             noexcept(noexcept(T())) {};
      \end{cppcode*}
   \end{itemize}
  \end{block}
\end{frame}
