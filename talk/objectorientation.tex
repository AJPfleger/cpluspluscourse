\section[OO]{Object orientation}

\subsection[Objects]{Objects and Classes}

\begin{frame}[fragile]
  \frametitle{What are classes and objects}
  \begin{block}{Classes}
    structs on steroids
    \begin{itemize}
    \item with inheritance
    \item including methods
    \end{itemize}
  \end{block}
  \begin{block}{Objects}
    instances of classes
  \end{block}
  \begin{block}{A class encapsulates a concept}
    \begin{itemize}
    \item shows an interface
    \item provides its implementation
      \begin{itemize}
      \item status, properties
      \item possible interactions
      \item construction and destruction
      \end{itemize}    
    \end{itemize}    
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitle{My First Class}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      struct MyFirstClass {
        int a;
        void squareA() {
          a *= a;
        };
        int sum(int b) {
          return a + b;
        };
      };

      MyFirstClass myObj;
      myObj.a = 2;

      // let's square a
      myObj.squareA();
    \end{cppcode*}
    \columnbreak
    \center
    \null \vfill
    \begin{tikzpicture}
      \classbox{MyFirstClass}{
        int a; \\
        void squareA(); \\
        int sum(int b);
      }
    \end{tikzpicture}
    \vfill \null
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Separating the interface}
  \begin{block}{Header : MyFirstClass.hpp}
    \begin{cppcode*}{linenos=false,gobble=6}
      struct MyFirstClass {
        int a;
        void squareA();
        int sum(int b)();
      };
    \end{cppcode*}
  \end{block}
  \begin{block}{Implementation : MyFirstClass.cpp}
    \begin{cppcode*}{linenos=false,gobble=6}
      #include "MyFirstClass.hpp"
      void MyFirstClass::squareA() {
        a *= a;
      };
      void MyFirstClass::sum(int b) {
        return a + b;
      };
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A word on namespaces}
  \begin{itemize}
  \item Namespaces allow to segment your code to avoid name clashes
  \item They can be embedded to create hierarchies (separator is '::')
  \end{itemize}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      int a;
      namespace n {
        int a;   // no clash
      }      
      namespace p {
        int a;   // no clash
        namespace inner {
          int a; // no clash
        }
      }
      int f() {
        n::a = 2;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=6,firstnumber=14}
      namespace p {
        int f() {
          p::a = 2;
          a = 2;  //same as above
          p::inner::a = 4;
          inner::a = 4;
          n::a = 5;
        }
      }
      using namespace p::inner;
      int g() {
        a = 3; // using p::inner
      }
  \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementing methods}
  \begin{block}{Standard practice}
    \begin{itemize}
    \item usually in .cpp, outside of class declaration
    \item using the class name as namespace
    \item when reference to the object is needed, use {\it this} keyword
    \end{itemize}
  \end{block}
  \begin{cppcode}
    void MyFirstClass::squareA() {
      a *= a;
    };

    int MyFirstClass::sum(int b) {
      int a = 0; // do not do that !
      a += this->a;
      a += b;
      return a;
    };
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Method overloading}
  \begin{block}{The rules in \cpp}
    \begin{itemize}
    \item overloading is authorized and welcome
    \item signature is part of the method identity
    \item but not the return code
    \end{itemize}
  \end{block}
  \begin{cppcode}
    struct MyFirstClass {
      int a;
      int sum(int b);
      int sum(int b, int c);
    }

    int MyFirstClass::sum(int b) { return a + b; };

    int MyFirstClass::sum(int b, int c) {
      return a + b + c;
    };
  \end{cppcode}
\end{frame}

\subsection{Inheritance}

\begin{frame}[fragile]
  \frametitle{First inheritance}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      struct MyFirstClass {
        int a;
        void squareA() { a *= a; };
      };
      struct MySecondClass :
        MyFirstClass {
        int b;
        int sum() { return a + b; };
      };

      MySecondClass myObj2;
      myObj2.a = 2;
      myObj2.b = 5;
      myObj2.squareA();
      int i = myObj2.sum(); // i = 9
    \end{cppcode*}
    \columnbreak
    \center
    \null \vfill
    \begin{tikzpicture}[node distance=2.5cm]
      \classbox{MyFirstClass}{
        int a; \\
        void squareA();
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        int b; \\
        int sum();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass);
    \end{tikzpicture}
    \vfill \null
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Managing access to class members}
  \begin{block}{{\it public} / {\it private} keywords}
    \begin{description}
      \item[private] allows access only within the class
      \item[public] allows access from anywhere
    \end{description}
    \begin{itemize}
      \item Default is {\it private}
      \item A {\it struct} is a {\it class} where all members are public
    \end{itemize}
  \end{block}
  \pause
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      class MyFirstClass {
      public:
        void setA(int a);
        int getA();
        void squareA();
      private:
        int a;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=6,firstnumber=9}
      MyFirstClass obj;
      obj.a = 5;   // error !
      obj.setA(5); // ok
      obj.squareA();
      int b = obj.getA();
    \end{cppcode*}
    \pause
    \begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,colback=red!5!white,colframe=red!75!black]
      This breaks MySecondClass !
    \end{tcolorbox}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Managing access to class members(2)}
  \begin{block}{Solution is {\it protected} keyword}
    Gives access to classes inheriting from base class
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      class MyFirstClass {
      public:
        void setA(int a);
        int getA();
        void squareA();
      protected:
        int a;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=6,firstnumber=13}
      class MySecondClass :
        public MyFirstClass {
      public:
        int sum() {
          return a + b;
        };
      private:
        int b;
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Managing inheritance privacy}
  \begin{block}{Inheritance can be public, protected or private}
    The influences the privacy of inherited members for external code.\\
    The code of the class itself is not affected
    \begin{description}
    \item[public] privacy of inherited members remains unchanged
    \item[protected] inherited public members are seen as protected
    \item[private] all inherited members are seen as private \\
      this is the default if nothing is specified
    \end{description}
  \end{block}
  \pause
  \begin{block}{Net result for external code}
    \begin{itemize}
    \item only public members of public inheritance are accessible
    \end{itemize}
  \end{block}
  \begin{block}{Net result for grand child code}
    \begin{itemize}
    \item only public and protected members of public and protected parents are accessible
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Managing inheritance privacy - public}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {public};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=6}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // OK
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Managing inheritance privacy - protected}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {protected};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=6}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // Error
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Managing inheritance privacy - private}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {private};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=6}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // Error
        int c = pub;    // Error
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // Error
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\subsection[Constructors]{Constructors/destructors}

\begin{frame}[fragile]
  \frametitle{Class Constructors and Destructor}
  \begin{block}{Concept}
    \begin{itemize}
    \item special functions building/destroying an object
    \item a class can have several constructors
    \item the constructors have the name of the class
    \item same for the destructor with a leading $\sim$
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      class MyFirstClass {
      public:
        MyFirstClass();
        MyFirstClass(int a);
        ~MyFirstClass();
        ...
      protected:
        int a;
      };
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=6,firstnumber=10}
      // note special notation for
      // initialization of members
      MyFirstClass() : a(0) {}
      
      MyFirstClass(int a_):a(a_) {}

      ~MyFirstClass(){};
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Class Constructors and Destructors}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      ~Vector();
      void setN(int n, int value);
      int getN(int n);
    private:
      int len;
      int* data;
    }
    Vector::Vector(int n) : len(n) {
      data = (int*)malloc(n*sizeof(int));
    }
    Vector::~Vector() {
      free(data);
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constructor and inheritance}
  \begin{cppcode}
    struct MyFirstClass {
      MyFirstClass();
      MyFirstClass(int a);
    }

    struct MySecondClass : MyFirstClass {
      MySecondClass();
      MySecondClass(int b);
      MySecondClass(int a, int b);
    }

    MySecondClass() : MyFirstClass(), b(0) {};
    MySecondClass(int b_) : MyFirstClass(), b(b_) {};
    MySecondClass(int a_,
                  int b_) : MyFirstClass(a_), b(b_) {};
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Copy constructor}
  \begin{block}{Concept}
    \begin{itemize}
    \item special constructor called for replicating an object
    \item takes a single parameter of type const ref to class
    \item will be implemented by the compiler if not provided
    \item in order to forbid copy, declare a private copy constructor without implementing it
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    struct MySecondClass : MyFirstClass {
      MySecondClass();
      MySecondClass(const MySecondClass &other);
    }    
  \end{cppcode}
  \pause
  \begin{exampleblock}{The rule of 3}
    \begin{itemize}
    \item if a class defines a destructor, a copy constructor or an assignment operator (see later), it should define all three
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Class Constructors and Destructors}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      Vector(const Vector &other);
      ~Vector();
      ...
    }
    Vector::Vector(int n) : len(n) {
      data = (int*)calloc(n, sizeof(int));
    }
    Vector::Vector(const Vector &other) : len(other.len) {
      data = (int*)malloc(len*sizeof(int));
      memcpy(data, other.data, len);
    }
    Vector::~Vector() { free(data); }
  \end{cppcode}
\end{frame}

\subsection[Static]{Static members}

\begin{frame}[fragile]
  \frametitle{Static members}
  \begin{block}{Concept}
    \begin{itemize}
    \item members attached to a class rather than to an object
    \item usable with or without an instance of the class
    \item identified by the {\it static} keyword
    \end{itemize}
  \end{block}
  \begin{cppcode}
    Class Text {
    public:
      static std::string upper(std::string) {...};
    private:
      static int s_nbCallsToUpper;
    }
    int Text::s_nbCallsToUpper = 0;
    std::string s = "my text";
    std::string uppers = Text::upper("my text");
    // now Text::s_nbCallsToUpper is 1
  \end{cppcode}
\end{frame}


\subsection[New]{Allocating objects}

\begin{frame}[fragile]
  \frametitle{Process memory organization}
  \begin{block}{4 main areas}
    \begin{description}
    \item[the code segment] for the code of the executable
    \item[the data segment] for global variables
    \item[the heap] for dynamically allocated variables
    \item[the stack] for parameters of functions and local variables
    \end{description}
  \end{block}
  \hspace{2.5cm}
  \begin{tikzpicture}
    \memorystack[size x=5cm,word size=1,nb blocks=6,addresses=0]
    \memorypush{code segment}
    \memorypush{data segment}
    \memorypush{stack}
    \memorypush{...}
    \memorypush{...}
    \memorypush{heap}
    \draw[->] (stack3-1.north) ++(-1cm,0) -- +(0,.3cm);
    \draw[->] (stack3-1.north) ++(1cm,0) -- +(0,.3cm);
    \draw[->] (stack6-1.south) ++(-1cm,0) -- +(0,-.3cm);
    \draw[->] (stack6-1.south) ++(1cm,0) -- +(0,-.3cm);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Stack}
  \begin{block}{Main characteristics}
    \begin{itemize}
    \item allocation on the stack stays in scope as long as it is on the stack \\
    It is destroyed when it is popped off the stack.
    \item memory allocated on the stack is known at compile time and can thus be accessed through a variable.
    \item the stack is relatively small, it is not a good idea to allocate large arrays, structures or classes
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Object allocation on the stack}
  \begin{block}{On the stack}
    \begin{itemize}
    \item object are created when declared (constructor called)
    \item object are destructed when out of scope (destructor is called)
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      MyFirstClass a; // default constructor called
      ...
    }  // destructor called

    int f() {
      MyFirstClass a(3); // constructor called
      ...
    } // destructor called
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Heap}
  \begin{block}{Main characteristics}
    \begin{itemize}
    \item Allocated memory stays allocated until it is specifically deallocated
      \begin{itemize}
      \item beware memory leaks
      \end{itemize}
    \item Dynamically allocated memory must be accessed through pointers
    \item large arrays, structures, or classes should be allocated here
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Object allocation on the heap}
  \begin{block}{On the heap}
    \begin{itemize}
    \item object are created by calling {\it new} (constructor is called)
    \item object are destructed by calling {\it delete} (destructor is called)
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      // default constructor called
      MyFirstClass *a = new MyFirstClass;
      ...
      delete a; // destructor is called
    }

    int f() {
      // constructor called
      MyFirstClass *a = new MyFirstClass(3);
      ...
    } // memory leak !!!
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Array allocation on the heap}
  \begin{block}{Arrays on the heap}
    \begin{itemize}
    \item arrays of objects are created by calling {\it new[]} \\
      default constructor is called for each object of the array
    \item arrays of object are destructed by calling {\it delete[]} \\
      destructor is called for each object of the array
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      // default constructor called 10 times
      MyFirstClass *a = new MyFirstClass[10];
      ...
      delete[] a; // destructor called 10 times
    }
  \end{cppcode}
\end{frame}


\subsection{Exceptions}

\begin{frame}[fragile]
  \frametitle{Exceptions}
  \begin{block}{The concept}
    \begin{itemize}
    \item exceptional Event breaking linearity of the code
    \item will be handled in dedicated place
    \end{itemize}
  \end{block}
  \begin{block}{Pratically}
    \begin{itemize}
    \item you can throw any object with {\it throw}
    \item you handle them using {\it try ... catch} blocks
    \end{itemize}
  \end{block}
  \begin{cppcode}
    try {
      if (0 == name) {
        throw std::string("Expected non empty name");
      }
      printf("%s\n", name);
    } catch (std::string e) {
      printf("empty name found\n");      
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exceptions}
  \begin{block}{Rules}
    \begin{itemize}
    \item exception will skip all code until next {\it catch}
    \begin{itemize}
      \item still destructors are called when exiting scopes
      \item but your own cleanup may not be
    \end{itemize}
    \item {\it catch} is selective on the exception type
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{fontsize=\scriptsize,gobble=6}
      class ZeroDivide {};
      
      int divide(int a, int b) {
        if (0 == b) {
          throw ZeroDivide();
        }
        return a/b;
      }
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{fontsize=\scriptsize,gobble=6,firstnumber=9} 
      int func(char* value) {
        try {
          errno = 0;
          long l = strtol(value,0,10);
          if (errno) {
            throw string("Bad Value");
          }
          divide(100, l);
        } catch (string e) {
          printf("%s\n", e.c_str());
        } catch (ZeroDivide e2) {
          printf("Division error\n");
        }
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Controlling exceptions}
  \begin{block}{Declaring expected exceptions}
    \begin{itemize}
    \item each function can declare a set of expected exceptions
    \item using the {\it throw} statement in its declaration
    \item other exceptions won't exit the scope of the function
      \begin{itemize}
      \item instead, the {\it unexpected} handler is called
      \item by default, it terminates the program
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    int func(int a) throw(int) {
      if (0 == a) {
        throw 2;  // ok, goes out
      } else {
        throw "hello"; // std::unexpected called
      }
    }
  \end{cppcode}
\end{frame}  

\begin{frame}[fragile]
  \frametitle{Controlling exceptions}
  \begin{block}{Good to know}
    \begin{itemize}
    \item The check in done at runtime, not at compile time
      \begin{itemize}
      \item unlike Java
      \end{itemize}
    \item When the {\it throw} clause is absent, any exception can go out
    \item To block all exceptions, use {\it throw()}
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    int func(int a) {
      // any exception can go out
    }
    int otherfunc(int a) throw() {
      // no exception can go out
    }
  \end{cppcode}
\end{frame}  
