\section{Advanced Topics}

\iffalse
\subsection[Advanced OO]{Advanced Object orientation}


\begin{frame}[fragile]
  \frametitle{Polymorphism}
  \begin{block}{the concept}
    \begin{itemize}
    \item objects actually have multiple types concurrently
    \item and can be used as any of them
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      Polygon *p = new Polygon();

      int f(Drawable *d) {...};
      f(p);  //ok

      try {
        throw *p;
      } catch (Shape e) {
        // will be caught
      }
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
      }
      \classbox[below of=Drawable]{Shape}{
      }
      \classbox[below of=Shape]{Polygon}{
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Method overloading}
  \begin{block}{the problem}
    \begin{itemize}
    \item a given method of the parent can be overloaded in a child
    \item but which one is called ?
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      Polygon *p = new Polygon();
      p->draw(); // ?
      
      Shape* s = p;
      s->draw(); // ?
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        void draw();
      }
      \classbox[below of=Drawable]{Shape}{
      }
      \classbox[below of=Shape]{Polygon}{
        void draw();
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Virtual methods}
  \begin{block}{the concept}
    \begin{itemize}
    \item methods can be declared {\it virtual}
    \item for these, the most precise object is always considered
    \item for others, the type of the variable decides
    \end{itemize}
  \end{block}
  \pause
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      Polygon *p = new Polygon();
      p->draw(); // Polygon.draw
      
      Shape* s = p;
      s->draw(); // Drawable.draw
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        void draw();
      }
      \classbox[below of=Drawable]{Shape}{
      }
      \classbox[below of=Shape]{Polygon}{
        void draw();
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}    
\end{frame}

\begin{frame}[fragile]
  \frametitle{Virtual methods}
  \begin{block}{the concept}
    \begin{itemize}
    \item methods can be declared {\it virtual}
    \item for these, the most precise object is always considered
    \item for others, the type of the variable decides
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      Polygon *p = new Polygon();
      p->draw(); // Polygon.draw
      
      Shape* s = p;
      s->draw();  // Polygon.draw
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        virtual void draw();
      }
      \classbox[below of=Drawable]{Shape}{
      }
      \classbox[below of=Shape]{Polygon}{
        void draw();
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}    
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pure Virtual methods}
  \begin{block}{Concept}
    \begin{itemize}
    \item methods that exist but are not implemented
      \item marked by an ``{\it = 0}'' in the declaration
    \item makes their class abstract
    \item an object can only be instantiated for a non abstract class
    \end{itemize}
  \end{block}
  \pause
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=6}
      // Error : abstract class
      Shape *s = new Shape();

      // ok, draw has been implemented
      Polygon *p = new Polygon();
      
      // Shape type still usable
      Shape* s = p;
      s->draw();
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        void draw() = 0;
      }
      \classbox[below of=Drawable]{Shape}{
      }
      \classbox[below of=Shape]{Polygon}{
        void draw();
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/polymorphism
    \item look at the code
    \item open test.cpp
    \item create a Pentagon, call its perimeter method
    \item create an Hexagon, call its perimeter method
    \item create an Hexagon, call its parent's perimeter method
    \item retry with virtual methods
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multiple Inheritance}
  \begin{block}{Concept}
    \begin{itemize}
    \item one class can inherit from multiple parents
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{tikzpicture}[]
      \classbox[]{Polygon}{
      }
      \classbox[below of=Polygon,node distance=1.5cm]{Rectangle}{
      }
      \classbox[right of=Rectangle,node distance=3cm]{Text}{
      }
      \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{
      }
      \draw[very thick,->] (Polygon) -- (Rectangle);
      \draw[very thick,->] (Rectangle) -- (TextBox);
      \draw[very thick,->] (Text) -- (TextBox);
    \end{tikzpicture}
    \columnbreak
    \vspace{2cm}
    \begin{cppcode*}{gobble=6}
      class TextBox :
        public Rectangle, Text {
        // inherits of both
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The diamond shape}
  \begin{block}{Concept}
    \begin{itemize}
    \item one class may inherit several times form a given grand parent
    \item are the members of the grand parent replicated ?
    \end{itemize}
  \end{block}
  \vfill
  \hspace{2.5cm}
  \begin{tikzpicture}[]
    \classbox[]{Drawable}{
    }
    \classbox[below left of=Drawable,node distance=2cm]{Rectangle}{
    }
    \classbox[right of=Rectangle,node distance=3cm]{Text}{
    }
    \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{
    }
    \draw[very thick,->] (Drawable) -- (Rectangle);
    \draw[very thick,->] (Drawable) -- (Text);
    \draw[very thick,->] (Rectangle) -- (TextBox);
    \draw[very thick,->] (Text) -- (TextBox);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Virtual inheritance}
  \begin{block}{Concept}
    \begin{itemize}
    \item inheritance can be {\it virtual} or not
    \item {\it virtual} inheritance will ``share'' parents
    \item standard inheritance will replicate them
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{tikzpicture}[]
      \draw node (title) [rectangle] {virtual};
      \classbox[below of=title]{Drawable}{
      }
      \classbox[below left of=Drawable,node distance=2cm]{Rectangle}{
      }
      \classbox[right of=Rectangle,node distance=3cm]{Text}{
      }
      \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{
      }
      \draw[very thick,->] (Drawable) -- (Rectangle);
      \draw[very thick,->] (Drawable) -- (Text);
      \draw[very thick,->] (Rectangle) -- (TextBox);
      \draw[very thick,->] (Text) -- (TextBox);
    \end{tikzpicture}
    \columnbreak
    \begin{tikzpicture}[]
      \classbox[]{Drawable1}{
      }
      \classbox[below of=Drawable1,node distance=1.5cm]{Rectangle}{
      }
      \draw[very thick,->] (Drawable1) -- (Rectangle);
      \classbox[right of=Drawable1,node distance=3cm]{Drawable2}{
      }
      \classbox[below of=Drawable2,node distance=1.5cm]{Text}{
      }
      \draw[very thick,->] (Drawable2) -- (Text);
      \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{
      }
      \draw[very thick,->] (Rectangle) -- (TextBox);
      \draw[very thick,->] (Text) -- (TextBox);
      \draw node at (1.5cm,1cm) [rectangle] {standard};
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Virtual inheritance}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/virtual\_inheritance
    \item look at the code
    \item open test.cpp
    \item create a TextBox and call draw
    \item Fix the code to call both draws by using types
    \item retry with virtual inheritance
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Virtual inheritance}
  \begin{alertblock}{Warning}
    in case of virtual inheritance it is the most derived class that calls the virtual base class' constructor
  \end{alertblock}
\end{frame}


\subsection{Operators}

\begin{frame}
  \frametitle{Operators}
  \begin{block}{Definition for operators of a class}
    \begin{itemize}
    \item implemented as a regular method
      \begin{itemize}
      \item either inside the class, as a member function
      \item or outside the class (for some)
      \end{itemize}
    \item with a special name (replace @ by anything)
      \begin{tabular}{llll}
        Expression & As member function & As non-member function \\
        \hline
        @a & (a).operator@() & operator@(a) \\
        a@b & (a).operator@(b) & operator@(a,b) \\
        a=b & (a).operator=(b) & cannot be non-member \\
        a[b] & (a).operator[](b)
        a-\textgreater & (a).operator-\textgreater() & cannot be non-member \\
        a@ & (a).operator@(0) & operator@(a,0) \\
        (@)a & (a).operator@() & cannot be non-member \\
      \end{tabular}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operators' example}
  \begin{cppcode*}{}
    struct Complex {
      float m_real, m_imaginary;
      Complex(float real, float imaginary);
      Complex& operator+(Complex& other) {
        m_real += other.m_real;
        m_imaginary += other.m_imaginary;
      }
    }

    Complex c1(2, 3), c2 (4, 5);
    Complex c3 = c1 + c2;
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Non-member operator example}
  \begin{cppcode*}{}
    struct Complex {
      float m_real, m_imaginary;
      Complex(float real, float imaginary);
    }

    std::ostream& operator<<(std::ostream& os,
                             const Complex& obj) {
      os << "(" << m_real << ", " << m_imaginary << ")";
      return os;
    }

    Complex c1(2, 3);
    std::cout << c1 << std::endl;
  \end{cppcode*}
\end{frame}




\subsection[Functions]{More around functions}


\subsubsection{Pointers and references}

\begin{frame}[fragile]
  \frametitle{Value, pointers and references}
  \begin{block}{Different ways to pass arguments to a function}
    \begin{itemize}
    \item by default arguments are passed by value
    \item but pointers can be used
    \item and references are also available
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    struct T {...};
    void func   (T value);  // by value
    void funcPtr(T *value); // pointer
    void funcRef(T &value); // reference
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Value versus pointers/reference}
  \begin{block}{Identical to C}
    \begin{itemize}
    \item by value, a copy is created
      \begin{itemize}
        \item calling the copy constructor for objects
      \end{itemize}
    \item using pointers, the memory address of value is passed
    \item using reference, a reference to value is passed
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    T a;      // constructor called
  \end{cppcode*}
  \pause
  \begin{cppcode*}{firstnumber=2}
    funct(a); // copy constructor called on enter
              // destructor called on exit
  \end{cppcode*}
  \pause
  \begin{cppcode*}{firstnumber=4}
    functPtr(&a); // no copy, but we pass a pointer
    functRef(a);  // no copy, and standard syntax
  \end{cppcode*}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Pointers vs References}
  \begin{block}{Specificities of reference}
    \begin{itemize}
    \item natural syntax
    \item will never by NULL
    \item cannot reference temporary object
    \end{itemize}
  \end{block}
  \begin{block}{Advantages of pointers}
    \begin{itemize}
    \item can be NULL
    \item clearly indicates that argument may be modified
    \end{itemize}
  \end{block}
  \pause
  \begin{alertblock}{Good practice}
    \begin{itemize}
      \item Always use references when you can
      \item Consider that a reference will be modified
      \item Use const when it's not the case
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsubsection{Constness}

\begin{frame}[fragile]
  \frametitle{Constness}
  \begin{block}{The {\it const} keyword}
    \begin{itemize}
    \item indicate that the element to the left is constant
    \item this element won't be modifiable in the future
    \item this is all checked at compile time
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    // standard syntax
    int const i = 6;

    // error : i is constant
    i = 5

    // also ok, when nothing on the left,
    // const applies to element on the right
    const int j = 6;
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constness and pointers}
  \begin{cppcode*}{}
    // pointer to a constant integer
    int a = 1, b = 2;
    int const *i = &a;
    *i = 5; // error, i is const
    i = &b; // ok, pointer is not const

    // constant pointer to an integer
    int * const j = &a;
    *j = 5; // ok, value can be changed
    j = &b; // error, pointer is const

    // constant pointer to an integer
    int const * const k = &a;
    *k = 5; // error, value is const
    k = &b; // error, pointer is const
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{constness}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/constness
    \item open test.cpp
    \item test pointer to constant
    \item test constant pointer
    \item test constant pointer to constant
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function constness}
  \begin{block}{The {\it const} keyword for class functions}
    \begin{itemize}
    \item indicate that the function does not modify the object
    \item in other words,{\it this} is a pointer to constant
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    struct Exemple {
      void foo() const  {
        m_member = 0; // Error constant, function
      }
      int m_member;
    };
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function constness}
  \begin{block}{Constness is part of the type}
    \begin{itemize}
    \item const T and T are different type
    \item however, T is automatically casted in const T when needed
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    void func(int *a);
    void funcConst(const int *a);

    int *a = 0;
    const int *b = 0;

    func(a);      // ok
    func(b);      // error : no matching function
    funcConst(a); // ok
    funcConst(a); // ok
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{constness}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go back to constness/basic
    \item open test.cpp
    \item test const members
    \item test const part of type
    \end{itemize}
  \end{alertblock}
\end{frame}


\subsubsection{Functors}

\begin{frame}[fragile]
  \frametitle{Functors}
  \begin{block}{Concept}
    \begin{itemize}
    \item a class that implements the () operator
    \item allow to use objects in place of functions
    \item and as objects have constructors, allow to construct functions
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    struct Adder {
      int m_increment;
      Adder(int increment) : m_increment(increment) {}
      int operator()(int a) { return a + increment; }
    };
    
    Adder inc1(1), inc10(10);
    int i = 3;
    int j = inc1(i);  // 4
    int k = inc10(i); // 13
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functors}
  \begin{block}{Typical usage}
    \begin{itemize}
    \item pass a function to another one
    \item or to an STL algorithm (see later)
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    struct BinaryFunction {
      virtual double operator() (double a, double b) = 0;
    };
    struct Add : public BinaryFunction {
      double operator() (double a, double b) { return a+b; }
    };
    double binary_op(double a, double b, BinaryFunction &func) {
      return bin_func(a, b);
    }
    Add addfunc;
    binary_op(a, b, addfunc);
  \end{cppcode*}
\end{frame}


\subsubsection{Copy constructors}

\begin{frame}[fragile]
  \frametitle{Copy constructors}
  \begin{block}{Concept}
    \begin{itemize}
    \item constructor called when replicating an object
    \item in particular when the = operator is used
    \item or when the object is passed by value
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    struct MyClass {
      MyClass(const MyClass& other);
      MyClass(MyClass& other);
    }
  \end{cppcode*}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Copy constructors}
  \begin{alertblock}{Usually not needed}
    \begin{itemize}
    \item Provided by the compiler
    \item Except when the compiler cannot know
    \item Usually associated to non trivial constructor/destructor
    \end{itemize}
  \end{alertblock}
  \begin{cppcode*}{}
    struct Vector {
      Vector(const Vector& other);
      ~Vector() { free(m_data); };
      int m_len;
      int* m_data;
    }
    Vector::Vector(const Vector& other) :
      m_len(other.m_len) {
      int* m_data = (int*) malloc(m_len);
      memcopy(m_data, other.m_data, m_len);
    }
  \end{cppcode*}
\end{frame}

\subsection{Templates}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{block}{Concept}
    \begin{itemize}
    \item The \cpp way to write reusable code
      \begin{itemize}
        \item aka macros on steroids
      \end{itemize}
    \item Applicable to functions and objects
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    template<class T>
    const T & Max(const T &A, const T &B) {
      return A > B ? A : B;
    }

    template<class T>
    struct Vector {
      int m_len;
      T* m_data;
    }
 \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{alertblock}{Warning}
    These are really like macros
    \begin{itemize}
      \item they are compiled n times
      \item they need to be defined before used
      \begin{itemize}
        \item so all templated code has to be in headers
      \end{itemize}
      \item this may lead to longer compilation times and bigger libraries
    \end{itemize}
  \end{alertblock}
  \newsavebox{\codepiece}
  \begin{lrbox}{\codepiece}
    \begin{minipage}{.35\linewidth}
      \begin{cppcode*}{gobble=8,linenos=false}
        template<class T>
        void func(T a) {
          return a;
        }
      \end{cppcode*}
    \end{minipage}
  \end{lrbox}
  \newsavebox{\codepiecea}
  \begin{lrbox}{\codepiecea}
    \begin{minipage}{.4\linewidth}
      \begin{cppcode*}{gobble=8,linenos=false}
        void func(int a) {
          return a;
        }
      \end{cppcode*}
    \end{minipage}
  \end{lrbox}
  \newsavebox{\codepieceb}
  \begin{lrbox}{\codepieceb}
    \begin{minipage}{.4\linewidth}
      \begin{cppcode*}{gobble=8,linenos=false}
        void func(double a) {
          return a;
        }
      \end{cppcode*}
    \end{minipage}
  \end{lrbox}
  \begin{tikzpicture}[rectangle,rounded corners]
    \draw node (template) [draw] {\usebox{\codepiece}}
          node (templatea) [draw] at (6cm,+1cm) {\usebox{\codepiecea}}
          node (templateb) [draw] at (6cm,-1cm) {\usebox{\codepieceb}};
    \draw[->,thick] (template) -- (templatea) node [above,midway,sloped] {func(3)};
    \draw[->,thick] (template) -- (templateb) node [below,midway,sloped] {func(5.2)};
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{block}{Arguments}
    \begin{itemize}
    \item can be a class, 
    \item you can have several
    \item that last ones can have a default value
    \end{itemize}
  \end{block}
  \begin{cppcode*}{}
    template<class KeyType=int, class ValueType=KeyType>
    struct Map {
      void set(KeyType &key, ValueType value);
      ValueType get(KeyType &key);
    }

    Map<std::string, int> m1;
    Map<float> m2;   // Map<float, float>
    Map<> m3;        // Map<int, int>
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates implementation}
  \begin{cppcode*}{}
    template<class KeyType=int, class ValueType=KeyType>
    struct Map {
      void set(KeyType &key, ValueType value);
      ValueType get(KeyType &key);
    }

    template<class KeyType, class ElementType>
    void Map<KeyType, ElementType>::set
       (KeyType &key, ValueType value) {
      ...
    }

    template<class KeyType, class ElementType>
    ValueType Map<KeyType, ElementType>::set(KeyType &key) {
      ...
    }
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{block}{Specialization}
    templates can be specialized for given values of their parameter
  \end{block}
  \begin{cppcode*}{}
    template<unsigned int N> struct Polynom {
      Polynom(float radius);
      float perimeter();
      float m_radius;
    };
    
    template<>
    struct Polynom<6> {
      Polynom(float radius);
      float perimeter() {return 6*m_radius;};
      float m_radius;
    };
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The full power of templates}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/template
    \item look at the OrderedVector code
    \item compile and run test.cpp. See the ordering
    \item reuse OrderedVector with Complex
    \item improve OrderedVector to template the ordering
    \item test manhattan order with complex type
    \item check the implementation of Complex
    \item try ordering complex of complex
    \end{itemize}
  \end{alertblock}
\end{frame}

\fi  %iffalse

\subsection[STL]{The Standard Template Library}

\begin{frame}[fragile]
  \frametitle{The Standerd Template Library}
  \begin{block}{What it is}
    \begin{itemize}
    \item A library of standard templates
    \item Eveything you need, or ever dreamed of
      \begin{itemize}
      \item strings, containers, iterators
      \item algorithms, functions, sorters
      \item functors, allocators
      \item ...
      \end{itemize}
    \item Very portable
    \item Very reusable
    \item Very efficient
    \end{itemize}
  \end{block}
  \pause
  \begin{alertblock}{Just use it}
    and adapt it to your needs, thanks to templates
  \end{alertblock}
\end{frame}

\subsubsection[Containers]{Standard containers}

\begin{frame}[fragile,label=STLcode]
  \frametitle{STL's in practice}
  \begin{cppcode*}{}
    #include<vector>
    #include<algorithm>

    std::vector<int> vi, vr(3);
    vi.push_back(5); vi.push_back(3); vi.push_back(4);

    std::transform(vi.begin(), vi.end(),      // range1
                   vi.begin(),          // start range2
                   vr.begin(),          // start result
                   std::multiplies<int>()); // function

    for(std::vector<int>::iterator it = vr.begin();
        it != vr.end();
        it++) {
      std::cout << *it << " ";
    };
    std::cout << std::endl;
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{STL's concepts}
  \begin{block}{containers}
    \begin{itemize}
    \item a structure containing data
    \item with a given way of handling it
    \item irrespective of
      \begin{itemize}
      \item the data itself (templated)
      \item the memory allocation of the structure (templated)
      \item the algorithms that may use the structure
      \end{itemize}
    \item examples
      \begin{itemize}
      \item string
      \item list, vector, deque
      \item map, set, multimap, multiset, hash\_map, hash-set, ...
      \item stack, queue, priority\_queue
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{STL's concepts}
  \begin{block}{iterators}
    \begin{itemize}
    \item generalization of pointers
    \item allowing iteration over some data
    \item irrespective of
      \begin{itemize}
      \item the container used (templated)
      \item the data itself (contained is templated)
      \item the consumer of the data (templated algorithm)
      \end{itemize}
    \item examples
      \begin{itemize}
      \item iterator
      \item reverse\_iterator
      \item const\_iterator
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{STL's concepts}
  \begin{block}{algorithms}
    \begin{itemize}
    \item implementation of an algorithm working on data
    \item with a well defined behavior (speed garantee)
    \item irrespective of
      \begin{itemize}
      \item the data handled
      \item the container where data live
      \item the iterator used to go through data
      \end{itemize}
    \item examples
      \begin{itemize}
      \item for\_each, find, find\_if, count, count\_if, search
      \item copy, swap, transform, replace, fill, generate
      \item remove, remove\_if
      \item unique, reverse, rotate, random, partition
      \item sort, partial\_sort, merge, min, max
      \item lexicographical\_compare, iota, accumulate, partial\_sum
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}
      
\begin{frame}[fragile]
  \frametitle{STL's concepts}
  \begin{block}{functions / functors}
    \begin{itemize}
      \item generic utility functions/functors
      \item mostly useful to be passed to STL algorithms
    \item implemented independently of
      \begin{itemize}
      \item the data handled (templated)
      \item the context (algorithm) calling it
      \end{itemize}
    \item examples
      \begin{itemize}
      \item plus, minus, multiply, divide, modulus, negate
      \item equal\_to, less, greater, less\_equal, ...
      \item logical\_and, logical\_or, logical\_not
      \item identity, project1st, project2nd
      \item binder1st, binder2nd, unary\_compose, binary\_compose
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\againframe{STLcode}

\begin{frame}[fragile,label=STLcode]
  \frametitle{More complex STL code}
  \begin{cppcode*}{}
    // Finds the first element in a list that lies in
    // the range from 1 to 10.
    list<int> L;
    ...
    list<int>::iterator in_range = 
      find_if(L.begin(), L.end(),
              compose2(logical_and<bool>(),
                       bind2nd(greater_equal<int>(), 1),
                       bind2nd(less_equal<int>(), 10)));

    // Computes sin(x)/(x + DBL_MIN) for elements of a range.
    transform(first, last, first,
              compose2(divides<double>(),
                       ptr_fun(sin),
                       bind2nd(plus<double>(), DBL_MIN)));
  \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{STL's concepts}
  \begin{block}{Welcome to lego programming !}
    \pgfdeclareimage[height=0.5cm]{AtlasLego}{AtlasLego.jpg}
    \includegraphics[width=\linewidth]{AtlasLego}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using the STL}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/stl
    \item look at the provided code
      \begin{itemize}
        \item it creates a vector a ints at regular intervals
        \item it randomizes them
        \item it computes differences between consecutive ints
        \item and the mean and variance of it
      \end{itemize}
    \item ``translate'' it to STL
    \item make sure that it's reusable for floats, doubles, ...
    \item use it with complex numbers
    \end{itemize}
  \end{alertblock}
\end{frame}

Warning :
  - template symtax awful (better in C++11)
  - hard to debug (compilers spit out garbage)
  - standard is not well defined


\subsection[Tools]{Useful tools}
\subsubsection{Compilers}
\subsubsection{Static analyzer}
\subsubsection{Debugger}
\subsubsection{Memory checker}
